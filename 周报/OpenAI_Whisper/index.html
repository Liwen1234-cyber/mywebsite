<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-周报/OpenAI_Whisper" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">OpenAI Whisper | Coisini</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doc.minddiy.top/周报/OpenAI_Whisper/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="OpenAI Whisper | Coisini"><meta data-rh="true" name="description" content="| 原始题目 | Robust Speech Recognition via Large-Scale Weak Supervision |"><meta data-rh="true" property="og:description" content="| 原始题目 | Robust Speech Recognition via Large-Scale Weak Supervision |"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doc.minddiy.top/周报/OpenAI_Whisper/"><link data-rh="true" rel="alternate" href="https://doc.minddiy.top/周报/OpenAI_Whisper/" hreflang="en"><link data-rh="true" rel="alternate" href="https://doc.minddiy.top/周报/OpenAI_Whisper/" hreflang="x-default"><meta name="google-site-verification" content="1FUPX6Qo4y3ecU623ShEurhgnjhSTjK49rRMhEDlzFA">
<link rel="stylesheet" href="/katex/katex.min.css">
<script src="/js/matomo.js" async defer="defer"></script><link rel="stylesheet" href="/assets/css/styles.79037026.css">
<script src="/assets/js/runtime~main.468f2b27.js" defer="defer"></script>
<script src="/assets/js/main.4763ab3e.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Coisini</b></a></div><div class="navbar__items navbar__items--right"><a href="https://minddiy.top" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Main site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><main class="docMainContainer_TBSr docMainContainerEnhanced_lQrH"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="theme-doc-markdown markdown"><header><h1>OpenAI Whisper</h1></header>









































<table><thead><tr><th>原始题目</th><th>Robust Speech Recognition via Large-Scale Weak Supervision</th></tr></thead><tbody><tr><td>中文名称</td><td>稳健的语音识别通过大规模的弱监督</td></tr><tr><td>发表时间</td><td>2022年12月6日</td></tr><tr><td>平台</td><td>arXiv</td></tr><tr><td>来源</td><td>openAI</td></tr><tr><td>文章链接</td><td><a href="https://arxiv.org/abs/2212.04356" target="_blank" rel="noopener noreferrer">https://arxiv.org/abs/2212.04356</a></td></tr><tr><td>开源代码</td><td><a href="https://github.com/openai/whisper" target="_blank" rel="noopener noreferrer">https://github.com/openai/whisper</a></td></tr><tr><td>视频讲解</td><td><a href="https://www.bilibili.com/video/BV1VG4y1t74x" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1VG4y1t74x</a></td></tr><tr><td>应用</td><td><a href="https://www.bilibili.com/video/BV1Pe4y1t7de/?spm_id_from=333.999.0.0" target="_blank" rel="noopener noreferrer">https://www.bilibili.com/video/BV1Pe4y1t7de/?spm_id_from=333.999.0.0</a></td></tr></tbody></table>
<blockquote>
<p>本文是 李沐 老师讲的 OpenAI Whisper 论文的 视频笔记。</p>
</blockquote>
<p>大家好，今天我们来讲解语音识别领域最近的一篇重要论文——OpenAI的Whisper。</p>
<p>简要来说，OpenAI GPT的作者在网上收集了将近70万小时带标注的语音数据，直接用这些数据训练了一个Transformer模型，几乎没有对模型结构做改动。</p>
<p>结果发现，这个模型的性能不仅能媲美，甚至超越了市面上所有开源包，甚至包括一些商业语音识别系统。</p>
<p>这个模型可以直接使用，无需任何微调，能够处理几十种语言，甚至支持同时翻译。</p>
<p>这就是这项工作的一个非常简明的概括。</p>
<p>当然你可能问说语音识别其实是深度学习用的最早的一个领域。它的成功早在于 AlexNet 在 ImageNet 上取得很好的成绩。为什么之前没有人去做这种比较大的带标号的数据呢? 原因还是说,什么样的语音数据代标号? 一般来说就是音乐吧,你的流行歌曲是有歌词的。你的电影吧,你是带字幕的。或者你的电视吧,也可能是带字幕的。但所有的这些东西都是受到非常强的版权的保护。如果你干了这个事情,你可能只能偷偷的干了。你可能不能拿出来说。OpenAI也是开了一个先河啊。就是说,只要我不说我的数据是哪里来的。我的模型照放不误,我的头条照样的上。所以在对版权的挑战上面,OpenAI绝对是走在最前面的。今天我们就给大家讲一讲这篇论文。当然这篇论文里面还是有很多技术的细节,是值得大家去讲的。另外一块呢,我觉得这篇文章也将会是一个比较有影响力的工作。也值得大家一读。</p>
<p>我们在上一期视频也给大家演示了Whisper的一个效果。我们再来看一下他自己 Blog 的几个示例。首先是一个比较快的语音转录。这是一个说的非常快的语音的转录。可以看到它的效果还是非常好的。你看它的这种专有名词翻的是比较对的。而且大小写甚至是也是弄对了。而且我觉得它的听力水平应该是超过我的呀。另外一看,这个是对于音乐的一个翻译。所以它能够有效的把这个背景的音乐给去掉之后呢。把这个语音翻译出来。这也多多少少证明了他们肯定是用了这种音乐来做训练的。然后这个是一个法语的翻译。这个应该是用手机录的一个有明显的空间感的一个声音。而且它是直接把法语转录成了英语。最后一个是一个带有严重口音的一个转录。感觉是墨西哥人说英语。至少我觉得是听得不是很清楚。然后他翻译的也是挺准的。他说唯一的是这个这个可能是个地名还是一个什么东西。翻译的不是那么的对。但整体是比较好的。好,这就是它的一个效果。接下来我们来直接看这篇文章。</p>
<p>我们先看一下标题。标题是说。稳健的语音识别通过大规模的弱监督。所谓的弱监督呢。通常是说你是有标号的。但你的标号的质量是一般。那么Large Scale就要理解了嘛。就是说因为我的标号质量一般呢。所以我能够采集很多这样子的数据。所以这个标题很简单。基本就是大力出奇迹了。</p>
<p>看一下作者。作者都是来自于OpenAI的作者。第一作大家应该是比较了解了。也是GPT系列的一作。这应该是OpenAI最近几年最活跃的科学家之一吧  。</p>
<p>摘要呢也非常的简单。它的第一句话呢讲是说。我们来研究一下。在网络上收集到的这些语音的脚本上面训练模型的一个效果。他说我发现如果把我的训练数据集拓展到 68 万小时。而且是多语言和做多任务训练的时候呢。这个结果非常的好。具体的好法是说 在这些标准的测试任务上面呢。它跟这些在这些任务的训练数据集上。充分训练好的模型相比。它的结果差不多。但是在这里 Whisper 是没有用这些 Benchmark 的训练数据集的。就是一个 Zero-short 的一个训练。</p>
<p>所以这个也有一定的道理对吧。就是你训练好的语音识别的模型。在应用到一个场景的时候。你就是能够直接去进行语音的识别。而不是说我换了一个地方的时候。还得在那个地方再采集一点数据。然后再做一次微调。那么用起来就更加难用一些了。</p>
<p>然后说跟人类比啊。这个模型呢。基本上跟他们的精度和稳健度是差不多。最后是我们发布了这个模型。大家可以去看一看。</p>
<p>结论写的也是同样的简单。他说Whisper指出。最近这些语音识别领域。大家对把整个<strong>弱监督的预训练做大</strong>这件事情。大家好像对它的认识不是很够。他说有了这个之后。我们就不需要做自监督或者自训练了。这个其实是在语音识别。最近几年用的比较多的一个方法。然后它的一个主要好处是说。你只要在这个大的数据集上训练好模型就行了。你不需要做任何的微调。就直接 zero-short 就行了。</p>
<p>可以看到整个摘要和结论。里面讲到的唯一的具体一点的技术细节。就是那个 68 万小时的训练数据。没有任何提出我提出了什么新的模型。新的损失函数或者什么新的训练算法。而且在结论里面说。我只要做预训练就行了。我之后也不需要微调。不要自监督。不要自训练。所  有东西都不需要。然后直接拿去用就行了。所以整个摘要和结论讲的一点就是说。高端的实材只需要最朴素的烹饪。</p>
<p>接下来我们来看导言。导言的第一句话是说。在语音识别领域。最近大家做的方法是用无监督的预训练。比如说 Wave2vec 2.0。这是Facebook他们在2020年的工作。核心思想是说。你采集大量这些原始的语音数据。不需要它的一些标号。</p>
<p>他这样做了两个好处。第一个好处是说。你数据采集起来就容易一些。因为你不要去收集它的标号。你不要做它的标号的清理。第二个是说。因为你的数据。你不要求它有标号。所以你能找到大量的。做没有什么太多版权问题的数据。比如说不是电影。不是音乐。而是很多人在YouTube上上传的。各种个人一点的这些数据。通常不会有人来告你说。你用了我的数据。然后有了这些数据之后。其实里面还是有很多信息。它是有个时序的信息。就跟之前的文本的预训练很像。比如说你可以训练模型。去预测下一个语音。或者是说中间挖掉一段去预测它。但具体来讲。<strong>Wave2vec用的是对比学习这个技术</strong>。大家可以看一下。我们之前对对比学习的一个描述。这期我们不会去讲。Wave2vec它用到的具体的技术。大概意思是说。在没有标号的数据集上。用自训练或者对比学习。这样子的方法。训练一个比较好的编码器。使得这个编码器 encoder。能对这些语音数据。做比较好的一个编码。</p>
<p>接下来作者说。因为这个方式。收集数据比较简单。2021年就 Google的作者。把整个数据集。做到了 100万 的这个大小上面。这个数据集大小是远远的超过了。在学术界。通常用的这个标准数据。都是在大到就到1000个小时的左右。然后在标准数据集上怎么用。就是你把你训练好的这个编码器。在这些数  据集的训练数据上。做一个微调。然后大家发现这样子的方法，比只用这些标准数据集，训练好的模型要好。因为你看过大量的没有标好的数据。你的编码器已经足够好了。特别的是说。因为你编码器抽特征已经很好了。所以我只需要一点点数据，做微调就行了。不是需要个几百小时，或者几千小时，可能就几十小时，或几个小时的数据就行了。这个就是最近几年语音识别领域，大家比较关注的一个方法。当然你如果你想做大新闻的话。你得说你们这些方法都不行。我有一个很不一样的想法。比你们的效果都要好。所以第二段就是抨击你们这些。使用没有标号数据做预训练方法的一个问题。</p>
<p>第二段首先作者提出了一个问题。就是说这些预训练好的。语音的编码器。它能够学习到比较高质量的。这种语音的一个表示。但是他们只是用纯。没有监督方式的方法训练好的。所以它没有一个很好的一个解码器。所以你要用的话。你还是得找一个带标号的数据，做一个微调。作者觉得微调是一个比较复杂的一个过程，而且需要一个熟练工才能干。那么作者的意思是说不用微调那就更好了。</p>
<p>我们稍微解释一下。就大家想一想之前Bert干的什么事情。在文本上面给你一段话。Bert 就是说预测。挖掉了一些空里面的词 长什么样子。或者预测说两个句子，是不是有一个前后的关系。训练好之后。Bert 那么对文本会有一个比较好的一个向量的表示。然后到具体的任务。比如说我做文本分类也好。做别的任务也好。他拿了这一个向量表示。再在上面加一个损失函数。就一个简单的分类层。再在你有标号的数据上做训练。这是因为之前预训练好的。比如说预测中间少掉了一个词。或者预测两个句子是不是一样。这个不是我们真正想要的东西。所以你在做具体的任务的时候。你还得给我你具体任务要的这些标号，然后再做一次微调就行了。所以这个就是作者抨击的。你没有解码器。当然你可以反过来说。我为什么不用GPT系列。就是它就是一个解码器。就是本文一做作者之前的工作。GPT的意思是说。我给我一段文字。我预测下一个词是什么样子。一旦我训练好之后。我这个模型可以直接拿来用。就我不需要再做进一步的微调了。这是因为我的解码器带了预测未来的一个功能。那么我任何的任务。我可以构造成一个问题回答的模式。比如说我要问你这个。句子是不是一个比较正的一个情绪的话。那我就构造一个问题出来。然后让你去预测这个问题的答案。那么通过构造这样子的问题。就是叫做 prompt。我们之后也会来看到这个事情。然后这个解码器能够直接预测答案。就不需要做微调了。那么你可以说。我为什么不用 GPT 这个模型。直接在语音信号上做呢。这是因为。语音信号它进来的是一个声波。你丢进GPT之后。它只能预测下一秒钟。或者下一个微秒里面这个声波长什么样子。但预测声波这个事情对我们没用。因为对语音来讲。我需要你把我这个词给预测出来。就是语音信号转成一个文本的信号。但是你直接没有标号的时候。你只能预测一个声波。所以你还是需要一个声波转文字的这个功能。那么你还是需要标号才行。这就是为什么说这无监督预训练好的任务。你都是需要一个微调。这是因为我们在这个地方要做一个格式的转换。只要你的预训练模型没有经过另外一个格式。就是文本的格式的样本的话。那么你总是需要微调才行的。</p>
<p>当然作者为了不把话说得太满。作者加了个角度说。Web2Web 的作者在去年有个工作。其实也是试图去说不要微调也行。接下来作者抨击的第二点是说。在微调的时候。很容易你会去对特定的数据集做一个过拟合。从而使得你在这个数据集上的性能比较好。但实际上你的泛化性不见得好。作者举了一个具体的例子。是他们之前的一篇工作。就是去年的一篇工作是说。他们在 ImageNet 这个数据上面。然后微调了一个任务。他们发现通过这个微调之后。我可以对某一些物体的识别有一个 9.2% 的一个提升。但是对同样的物体。但是在别的数据集上。他就没有看到任何的一个增长。所以他说。就算你在某个数据集上。可能比人类做的要更好。但是你不代表你真的在别的数据集上。就比人类要好了。</p>
<p>所以这个有一定的道理。就在 ImageNet 这个数据集上。100万的图片。1000类的类上面。早在五年前卷积神经网络就比人类要更好了。但实际上你说现在这种图片分类的这些模型。真的比人类在所有地方都要好吗。不见得。在那些你的训练数据没有见过的地方。这些模型不见得是要比人类好的。</p>
<p>所以作者的核心观点是说。无监督的预训练。确实把你的编码器改进了很多。但是你没有相对应的高质量的解码器。这会是你的一个巨大的缺陷。你真正的语音识别系统的目标。就是应该能够 out of box。就是我拿出来就可以用。还不需要说拿到我的具体的地方之后。还要做进一步的调整。所以作者说一个好的语音识别系统。就不应该说我换到一个新的部署的环境里面。就得训练一个新的解码器。</p>
<p>接下来的第三段就回到了有监督学习。作者说把你多个数据集放在一起之后。你训练出来模型的稳健性和泛化性。都比在单数据集上训练的要好。  但是它的问题是之前的工作。也就是把七个这样子的数据集放在一起。也就得到了一个 5000 个小时的训练数据集。跟之前的无监督学习的 100 万个小时。还是差的比较远。所以这个思想往下延展。就是你放松一下你整个标号的一个要求。这样子能达到更多的一个数据集。这里提了两个工作。第一个工作。去年的工作。在YouTube上爬了一万个小时的数据集。主要是把一些视频和里面的字幕抓出来作为它的标号。作者的评价是说。在这种数量和质量之间做权衡。通常是一个不错的选择。就是说你为了追求数量以及说你样本的多样性。你可以多多少少的降低一点质量。虽然这个思路在语音识别里用的不多。但是在计算机视觉作者举了两个工作。18年、20年的结果都是使用。标号质量更差一点的图片。获得更大的一个数据集。</p>
<p>铺垫了那么久的话。那就引出了本文的核心卖点。这个工作。我们把<strong>弱监督的数据集。拓展到了68万小时。然后这个办法叫做Whisper</strong>。虽然我觉得有一点点悬是说这个名字到底是指这个数据集。还是指你这个模型。不管怎么样。我们就用Whisper这个名字。</p>
<p>然后接下来一段是说。不仅大呀。而且在多样性上是有改进的。在这68万小时里面。11万小时是覆盖了96种语言。而且在这个里面有一十二万小时是。讲的是一种语言。但是它的标号是英语。作者的一个核心发现是说。当你的模型真的足够大的时候。你其实做这种多语言的以及多任务的训练，其实是有好处的。</p>
<p>导言的最后一段跟你的结论是重复的。他的第一句话是说。把这种弱监督学习做大。在语音识别里面。大家关注的不多。然后我们使用这个方法。可以不用用自监督自训练。能达到很好的结果。这两段话其实在结论里面，就是一模一样的 话。最后说我们这个代码放这个地方。大家可以去下载。</p>
<p>这就是导言。跟前面比还是一样。没有太多干货。还是那个68万的训练数据集。但是多多少少交代了一点上下文。他的一方面是说。前面的工作已经把无监督学习。拓展到了 100万 小时的训练数据。标号的数据，现在大概也就做到 4万 的一个规模。所以他这篇文章的一个大的贡献。是把这4万小时的数据。拓展到68万小时。但你可能会问说。其实这个工作。跟你在导言的后面一段更加相关一点。就是你在人家的基础上。直接把这个训练集做得更大了。那你为什么在写的时候。你不把这个东西写到前面。或者写到摘要里面。我觉得作者可能是有这么两点考虑。第一点考虑是说。如果你真的这么写的话。那么人家读下来。读到你中间那一段的时候。你会发现说。跟前面工作比。你干了啥。你就是把这个数据集做到更大一点。从 4 万做到 68 万。感觉是一个体力活。如果你就是干了体力活的话。更多是一下工程上的东西。那么你的科学上的。学术上的贡献在哪里。大家可能会有这个疑问。第二个是读者看到这里的时候。如果没有特别仔细去看。可能会说。你卖你 68 万很大。但是之前。Google不是已经做到你百万吗。比你这个数据还大一点。那么你凭什么就厉害一些。那么作者接下来得解释说。之前他们的工作是没有用标号的。我这里是有标号的。但你这么讲。不一定是一个加分项。别人会觉得说。一个模型。假设能用没有标号的数据。能做到很好的效果。比你用有标注的数据。做到同样的效果。当然人家是更厉害一点。在至少在算法上也赢了。所以作者在这里的思路是去攻击。你这种没有标号的数据。在部署的时候。可能还需要微调。然后我们这里训练的数据。用起来更加简单一点。第二点是说。他完全不提自己在模型上的贡献。其实他是有贡献的。但是在这里完。因为你那点贡献放在这里。吹得过多的话。可能是一个反向的一个效果。</p>
<p>第二章呢。讲的就是他们的方法了。其中的最关键的第一个。就是数据是怎么样处理的。我们来看一下。他第二段说。我们跟之前这种语音识别系统。不一样的地方是说。我们直接去预测这种原始的文本。所谓的原始文本。就是说没有做什么标准化。纯粹是依赖我的序列到序列。这个模型够强大。能把这东西给你全部还原出来。这里的好处是说。我整个系统直接输出。我最后要的东西。还不需要一个事后的额外的。一个反向的文本归一化的过程。</p>
<p>所谓的文本归一化。包括了比如说。我们把所有的单词变成小写。或者把所有的标点符号去掉。比如说所有这种缩写形式把它展开。那么这样当然会让你的模型。训练更加简单一点。但是事后你还得做一个模型。或者做一些规则。把它又还转回去。比如说句子的开头要大些。或者句子之间加上句号。这里的意思是说。只要我的数据足够大。这些东西都不用做。反正所有的情况。我的数据里面都可以出现。</p>
<p>接下来他说我把互联网上。所有这些语音。而且有对应文本的。这些文件给你扒下来了。这样导致我们有一个。非常多样化的数据集。然后覆盖了很多。这样子不同的说话的环境。然后你的录制的一个环境。有的是手机录的。可能有的是专业摄影棚录的。或者是你说话的人和你的语言。</p>
<p>接下来一段是说。虽然你的音频质量。有多样性挺好的。就是说你既想要录制很好的声音。你也想比较混乱的。比如说你用手机在室外的时候。录的很嘈杂背景的声音。这样都能让你的模型更加稳健。但是你文本质量的多样性就不好了。就是说最好把那些质量不好的文本。就是你的标号给去掉。他说为了做这个事情。我们做了一个自动的过滤器。然后来看一下。他们自动过滤器长什么样子。</p>
<p>首先他要过滤掉的是说。你的文本可能是一些。现有的语音识别系统识别出来的东西。假设你想训练一个模型。比人家系统要好的话。那你最好不要让人家的东西作为你的标号。不然的话。你的系统可能会比别人更差。前面的研究表明。假设你的数据集里面有混着人标的数据。和机器生成的数据的话。那么很有可能这些数据。会让你的系统性能变得更差。所以他需要把这些全部是由机器生成出来的文本。全部检测出来。他这里用了很多规则性的东西。他说在 ASR 系统生成出来的东西。可能会有自己的特点。比如说他没有比较复杂的标点符号。什么冒号呀。问号呀。或者没有格式化的一些空白字符。比如说换行字符。或者呢。全部是大写。或者全部是小写。然后说。这些系统还是多多少少做一些后面的。这些后处理的工作使得你的出来的文字。更加像自然语言一样。但是他说这个东西也基本上是一些基于规则的。或者简单的方法。还是能有办法检测的。所以这个是他的第一个方法。</p>
<p>他第二个方法干的事情呢。是说。他把整个声音的语言给你先检测出来。他用的是一个这样子的数据集。然后呢。他又用 CLD2。这是Google开发另外一个软件。去把文本他的语言检测出来。假设你声音检测到的语言。和你文本检测语言不一样的话。他就把它删掉了。但反过来。他有一个任何语言到英语的一个翻译的任务。就是说你的文本如果是英语。那么你的语音呢。可以是任何东西。如果你文本不是英语的话。那么你要跟你的语音一定是要配上的。那么最后还有一些去重啊。就是说如果文本之间长得很一样的话呢。我们就把它消掉了。好。这个就是基本上是两个他的数据过滤的方法。</p>
<p>接下来。他说我们把这些音频文件呢。分 成30秒的这种区间。然后呢。把它对应的这个文字呢。把它弄起来就变成了一个训练的样本。如果里面没有人说话了。也放进去。只是做一些下裁样。这好处是说你能够去区分。到底里面有没有人在说话。然后最后他还有一个额外的一个过滤的步骤。就是说我先在上面训练一个模型。然后再去看说啊。这些错误率非常高的这些文件。里面到底是谁。然后他们发现啊。其实面有很多是啊。可能就转录了一半。或者是说啊。整个转录的时间和你真的音频是没有对起来的。然后他也把这些东西全部删掉。最后一点是说。因为我是网上收集的数据啊。他要跟他的这种用了测试的数据集呢。要去重。因为不然的话。你可能测试数据。比如说这是一个 TED 的测试数据。很有可能他们是把整个 TED 爬下来了。所以等下是说我的测试样本。其实我在训练样本里面出现过了。那肯定是不行的。</p>
<p>这个就是对他的训练数据的一个描述。大家看到这里的话。有没有发现有一点他没写的。就是说他没说数据是怎么来的。他只是说我在互联网上把数据找下来了。从来没有说是在互联网的什么地方找的。以及这个数据里面到底是什么东西。等会你可以看到整篇文章写来是很长的。特别是后面这些啊。实验的部分写的特别的详细。而且他代码也公布了。预训练模型也公布了。所以他也不是一个很低质量的一篇文章。在这个地方他没写。肯定是有他的原因的。我觉得很明显的原因是说。这个东西不能说。说出来会有问题。比如说他的 Demo 里面有给大家看说。一个音乐怎么样去识别歌词。那么很有可能他是爬了很多音乐了。那么在美国的话。最大的音乐网站是 Spotify。很有可能他们是把 Spotify 给爬了一下。如果你在文章里面说我们爬了 Spotify。Spotify 可能会告你。或者你反过来想。说你在国内。你是一个国内某一家创业公司的员工。你写了篇论文说。我们把腾讯音乐全部爬了下来。然后用来做训练。训练一个数据。我们可能未来还要拿去卖钱的。特别在美国版权保护是非常的严格的。大家也许看过新闻是说很多年前。有人说下了很多音乐。最后被要求赔几百万。以及说如果你使用 YouTube 的话。你可能在YouTube上搜不到很多迪斯尼的音乐。甚至是说你唱迪斯尼的歌。然后把它传到YouTube上。迪斯尼很有可能会向YouTube。收取它的版权费。那么你的模型扫了那么多遍。你的数据到底要不要收钱呢。好像最近看新闻是说。音乐行业对这种帮助作曲的软件。好像意见比较大。是因为这些软件。通常是在现有的音乐上面训练出来的。那么你会不会有侵犯版权的问题。所以这个其实是一个。大家关注的一个问题。我觉得除了音乐之外。他们很有可能还是拍了什么电影。或者别的一些有版权的信息。所以这些细节可能是不能写出来的。反过来讲如果真的是这样子的话。我觉得OpenAI的胆子也是挺大的。因为很多东西是藏不住的。你像这个模型出来。大家那么多人去看。可能大家会把Whisper。放进他们的产品里面。但你无法保证说。未来会不会有人泄露说。你这个模型的数据是什么。一旦大家知道了的话。那么会有带来的版权问题。怎么样做。可能就会大家的一个热议的话题吧。</p>
<p>接下来我们来看 2.2 模型。它的模型它说我们这篇文章。其实关注的主要是。怎么样做大规模的有监督的预训练。它模型本身没有做太多事情。它说我们直接用了最简单的。off-the-shelf的模型。具体来说它其实就是用的。原始的带编码器和解码器的Transformer。</p>
<p>所以Transformer是2017年的工作。这个工作真的就是出道就是巅峰。5年过去了。Transformer后续的变种没有上万。也有上千。但是这些变种都没有怎么对Transformer，这个架构做大的调整。基本上就是变变宽变变深。但是里面的结构基本上没有太多调整。不像当年的卷积神经网络。被大家改得一塌糊涂。就是这里分开那里合起来。然后这里宽一点那里窄一点。所以Transformer虽然看上去比较复杂。但实际上只要搞懂了。它模型的本身后续的工作。都是相对来说比较简单的。</p>
<p>接下来它的声音是怎么样输入进去 Transformer 的。它说我所有的音频从采样到 16000Hz。然后再把它变成一个 80 通道的。Log-magnitude Mel Spectrogram。</p>
<p>如果大家对这一块不熟的话。我稍微给大家解释一下这是个什么东西。这个是我随手在 Google 搜来的一篇博客。就讲了一下这个是什么东西。时序信号它是一个一维的一个信号。就是在每一个时间点上。比如说是 15000Hz 的话。每个时间里面有 15000 个点。每个时间点上会有一个数值。数值是它的 Amplitude。当然你可以把它剪成一段一段的输入进去。但是它有很多问题。比如说它的音量是可以调的。比如说我把音量再大一点。音量调小一点对吧。所以通常来讲我们会它做一定的变形。最常见的变形就是抽 傅里叶 吧。把时序变到频谱上去。傅里叶 我就不讲了是什么东西。就是说它可以把一段时序的信号。抽到你的频率上面。然后看每一个频率上你的能量有多大。所谓 Spectrogram 是说。我在时间轴上每一个时间。我切一个小时序窗口出来。比如说在 5秒 这个地方。我比如说往前面看 100 毫秒。往后面看 100 毫秒。那么在这个 200毫秒 的窗口里面。做一下 傅里叶。把它每一个频率上的能量给你算下来。算在这个地方。所以这样子的话。我就从一个一维的信号。变成了一个二维的信号。我既有时间的维度。我也有频谱的维度。所谓的Log Scale。就是把整个能量做一下Log。也就变成了我们常见的 DB 吧。就是我们用来衡量一个声音信号。强弱的一个DB。它是一个Log Scale的。那么最后的最后什么叫做 Mel。Mel 是因为。人类对不同频率的响应是不一样的。人类对低频响应比较好一点。对高频信号。区别度就没那么大一点。所以 Mel 就是说。我在低频那边。就是把分辨率做得高一点。在高频那边分辨率做得低一点。所以它做出来的频谱图。在低频上面它的分辨率会高一点。像这样很高的频率。它基本上就全部是放在一起了。所以最后你可以看到。我一个时序的信号。进来之后就变成了一个2D的东西。你也可以认为是说。我们对每一个时间点上抽了一个特征。所以这个频谱就是它的特征。</p>
<p>具体来说。它这里用了 80 个通道。也就是说每一个时间点。它抽了一个 80 维度的特征。然后它每一个时间窗口是用的 25 毫秒。就每一次我们掐一段25毫秒的窗口。把里面的这些点拿出来。就我们 一秒 里面有 16000 个信号。所以每一个窗口里面。大概是 600 多个点（窗口有重叠）的样子。然后把它做 傅里叶 之后。再后通过Mel。做到一个 80 通道里面。然后每一次我窗口是往前滑动10毫秒。</p>
<p>记得我们之前是每一次切30秒钟出来。那么每一次窗口滑动10毫秒的意味就是说。那么我一个常为30秒的云信号。最后变成了一个 3000 个数据点。然后每一个数据点上它的维度是80。那么换算成之前大家更熟悉的文本的话。就每一次我一个段落进去。就是 3000 个词。每个词它的那个词嵌入的长度是 80。</p>
<p>最后它把所有的数值放在 +1 和 -1 之间。然后它的均值大概也是0。所以这个就是整个数据的预处理。</p>
<p>接下来讲的是整个你的模型架构。我们可以看下这张图就是比较清楚的。首先你的输入长度是3000。然后你的特征维度是80。它首先进到 两个一维的卷积层 里面。为什么这是一维呢。虽然这是个二维的东西。但是 80 是一个通道。这是你的特征维度。所以你其实只有一个时间维度是 3000。它的第一个卷积和第二个卷积的 kernel 的长度是3。然后第二个卷积有个 stride 等于2。所以这样出来之后。它就是一个 80。然后乘以 1500 的一个东西。</p>
<p>那么为什么在这个地方用卷积层。卷积层它是对局部信号比较敏感。就说长为3的这个核。然后它每次就看三个东西。然后它对局部的细节比较敏感。然后两层加起来的话。它就给你看到大概是5的一个窗口。最后一层的它用了一个。stride 等于2。就等于是把我的序列长度从 3000 降到了1500。就等于我后 面的计算就减半了。那么反过来说。你为什么不直接做成一个1500的序列进去呢。是因为如果做1500的话。那么你的采样的这个窗口就变成了50毫秒。但50毫秒可能对于一个词的判断来讲。可能长了一点。50毫秒你可能会讲两个词。所以你用个25毫秒。最好是精度比较高一点。然后用卷积神经网弄了。因为它相对比较便宜。它又能够把你的时间分辨率再降一点。然后把特征给抽出来。使得你后面的计算更加简单一点。这个是它的一个考虑。所以除了这个之外。它其实没有做太多的一个变换。</p>
<p>它的整个架构就是一个标准的。Transformer的 编码器-解码器 的架构。这进去之后。就是1500个词进去之后。那么把整个特征抽出来。然后放在它的解码器里面。那解码器呢。输入了就是你的这些。你先不看前面这些东西。这些prompt。后面就是你整个这个语音, 它对应的一个文本。每次我给前面一段。比如说 The quick。然后就预测brown。就是每次预测下一个词。那么就是一个标准的编码器-解码器。序列到序列的一个学习。但它有提到一点点的改动。就是比如说 pre-activation。但我觉得这个东西。都不是那么的重要。</p>
<p>最后它说它的tokenizer。它用的是, byte level 的BPE。大家可以看一下。我们之前对它的一个解释。核心思想是说。每一次我去切一个词干出来。然后统计一下它的频率，把频率比较高的一些东西留下来。它直接用的是 GPT2 的实现。但是 GPT2 是一个纯英语的模型。这个地方它做了多语言。所以它的做法是说。它重新把它训练一次。就哪些 token 要留下来。但是它的整个词典大小是没有变的。</p>
<p>我觉得这个大小可能有一点不够吧。比如说中文我们的词。就至少有几万对吧。然后你要词组的话更加多一点。不像英语。而且你还有别的文字。  比如说阿拉伯语、韩语，之类的。所以你在词典大小不变的情况下。很多长尾的这些词组，你就把它丢掉了。</p>
<p>这个就是它的模型。还是真的是比较标准的模型。它唯一加的就是。前面的两个卷积层。但是卷积层对于语音信号来讲。确实是用的挺多的。所以也不算是这个地方的一个独创。</p>
<p>接下来的 2.3 章。讲的是多任务的一个设计。在这个地方，我觉得这是整个系统的一个核心的设计。作者说虽然你的语音识别模型。它主要干的事情是说。给我一个特定的语音的片段。把里面说的哪些词给我识别出来。但实际上对大部分的。这种语音识别系统来讲。它还要干很多别的事情。比如说。是不是有人在说话。就是 VAD。是谁在说话。以及说我识别出来的这些文字。最后能把它做成一个。符合书写习惯的一个文字。比如说大小写。标点符号要加上。通常来讲。这些部分是额外设计的。就是每一个模型干一个事情。然后把所有这些东西串起来。变成了一个完整的一个系统。然后在这篇文章里面。作者说我希望有一个单模型。能把所有这些任务全部做好。他说对一个同样的一个输入的语音。我可以做 转录。可以做翻译。可以做 VAD。可以做时间戳。也可以做语言的一个检测。</p>
<p>我觉得用一个单模型。做所有的任务。当然从设计上来说。是看上去干净一点。而且从写文章角度来讲。我觉得听上去。新颖性 更高一点。但在实际的使用中。可能还是有一些的问题。我能想到两个问题。第一个是说做VAD。就是检测是不是有人说话。这样子的模型。通常来讲。我们希望他跑得快一点。比如说我的手机想看。是不是我在喊他。那么他最好的办法是说。他的麦克风一直在记录声音。然后他有一个很小的模型。一直在跑。这样子功耗也不会很高。一旦觉得我在喊他的时候。那么他就会去触发一个大的模型。来跑我这个任务。那么如果你把这个功能。做进你的整个大模型的话。意味着是说我。一段语音信号过来。我得在整个大的模型。去跑这个事情。看看有没有有人在说话。那么整个开销就比较大了。那么第二个问题是说。假设我同时能做五个任务。其中有一个任务。做的比较差的时候怎么办。那么剩下四个任务还行。那么我可能就说。对这个做的比较差的任务。多收集一点数据。再往前再训练训练。那么你训练这个任务的时候。一他训练起来是比较贵的。对吧。第二个是说，会不会影响到我，其他的模型的性能呢。更具体一点的是说。Whisper其实对这个，VAD的任务做的一般。我们上一个视频。也没有用 Whisper 来检测。哪一段我们是没有说话的。还是用一个。两三年前的一个任务来做的。那个模型跑得也挺快的。然后准度也挺高的。所以这个时候你就要做取舍了。就是说我到底是要做一个。All-in-one 的一个模型呢。还是对每一个任务训练的一个模型。这样子有多个模型。但这个多个模型。肯定也是共享一些层的。比如说最底层的。这些 encode-decode 的架构，很有可能还是能够共享的。只是说最后你的输出会不一样。</p>
<p>接下来看一下它具体的设计。所以它的多任务呢。有那么几个任务。一个是说给你一段英文的语音，把它转录成英语的文字。第二个是说，给你一段任何语言的语音，然后转录成英语的文字。第三个是说，给你任何的语言的语音，然后转录成它对应语言的一个文字。最后是说给你一段背景的音乐，你告诉我说没有人说话。就是这四个任务。</p>
<p>然后具体来看。它整个任务是怎么表示的呢。它使用的是下面这个图。它使用了一个 Prompt 的一个格式。首先它不同的任务，是通过前面不同的这些 Token 的组合，来进行区别的。具体来讲，这有三种不同颜色的一个词。一个是一些特别的 Token。就是说一些。你可以认为是一些控制的模块吧；文本的 Token，以及说时间戳的一个Token。首先这是起点。有一定的概率告诉你说，前面一段我们转录出来是什么，然后它对应的这些文本，和它的时间戳在这个地方。也有一定的概率是直接开始。告诉我说开始我的转录。开始转录之后。第一个是说，把这个语言给你学出来，就是这是什么语言。就是它有99种语言，每种语言它对应的一个特殊的一个Token在这个地方。就接下来你告诉他说。你是做转录呢。就是说你 X语言 到X语言文字的一个翻译。然后它有两个走向。一个是有时间戳的。告诉你说。接下来这一段文字。它开始的时间是什么。它的结束的时间是什么。这里面就是一句话。或者是一句话的一段吧。这也是我们上一期视频看到的。就是说做字幕就是这么做出来的。然后把这30秒钟全部做完之后。告诉他说这个结束了。第二个选项是说。它没有时间戳，只有它的文字。等于是说你把这些时间戳删掉就行了。然后也说结束。到语言这个地方之后。它的第二个走向是做翻译。就是说你不管说的是 什么文字。我最后都要出英语。那么还是一样的。就是要么你可以有带时间戳的。要么就没有带时间戳的。再回过头来。还有一个是说。我告诉你。这一段里面其实是没有人说话的。就告诉你说。no speech。那就是做VAD了。</p>
<p>所以看到它不同的任务。就表示成了一个这样子的控制流。所以从模型角度来讲，它的解码器就是一个很标准的一个解码器，每一次给一个序列的前面一些词，去预测下一个词长什么样子。那么它的好处很明显，就不像我们之前像 Bert 一样的，对不同的任务，你可能加一个不同的一个输出层；然后对它设计自己的一个损失函数，然后每次数据进来之后。你还得判说，这个数据对应的是这个损失走这边，做损失相加是怎么样子。在这个地方我就是一个输出，反正就是输出一个下一个词，就是一个标准的一个语言模型。所以你的输出也好。你的损失也好。只有一个东西。而且你对这种任务的表达也是非常的灵活的。但反过来它的问题是说。假设其中的有一个任务做的不好的时候。你怎么样对这个任务做微调呢。但因为所有东西大家都是共享的。那么你总不能说。我就专构造这个任务相关的数据。丢进去训练。那么大家一起跟着动。之前像 Bert 那样的这个任务。还有自己的一个输出层。我可能只微调那个输出层，也可能就行了。但现在这个地方。大家都共用一个输出层。所以你就希望是说，最好大家所有任务都做的差不多，就比较好了。</p>
<p>第二章的最后一节。就是训练的一些细节。这表一呢。讲的是它的这五个模型。Tiny,Base,Small,Medium,Large。基本上就是不同的层，然后不同的宽度，以及不同头的个数，最后是小模型就是40兆。然后大模型就是 1.5B 的一个可学习的参数。然后另外一些细节也是挺标准的。它用 的是 FP-16。然后动态的调了这个损失。它没有讲自己是用什么机器训练的。但我觉得如果你用的是 FP-16 的话。那你可能是用的比较老的。然后用的 AdamW。然后用的梯度的一个Clipping。然后你的学习率。也是有一个 Decay 在这个地方。Batch size是256。最后它说我们的数据。大概训练的 2 到 3 个Epoch。那你的数据是 70万 小时的话。那等价是说你训练的差不多。150万到200万小时的一个数据吧。就因为你只扫了数据两三遍了。所以Overfitting 可能不是一个大问题。更大的问题可能是你这个模型训练的。就不是很充分。</p>
<p>最后一段讲的是说。Whisper好像对于人的一个识别。做的不是很准。因为有时候你的脚本里面。包含了说是谁在说什么。但作者认为如果只冲30秒的时间里面。去看谁在说话。这个比较难。然后他们的解决方案是说。在训练完之后。然后他再把这些脚本里面。没有包含这种说话人信息的。这个东西挑出来。然后再Fine tune一下。就在之前的技术上继续训练。然后去去除掉这个行为。</p>
<p>这种单模型确实在设计上好很多。然后你做预测也方便很多。但是真的在debug上面。就有个任务做的不好的时候，可能就真的比较麻烦一些。所以我觉得这样的设计，还是有很强烈的，个人的偏好在里面。</p>
<p>接下来我们来看一下第三章 实验。首先它的设置是。它用的是 Zeroshot。意思是说它会在，很多语音识别的数据集上，去评估 Whisper性能。但是 Whisper 是不会再用到，这些评估数据局的训练集。所以在这个情况下，它是要亏一点点，因为别人的对比算法很有可能是用了人家数据集的训练集进行训练的。然后评估的准则，在语音识别里面。通常是用 Wer，就是词错误率来衡量。</p>
<p>词错误率的预测在这个地方。大概的意思是说，假设你要预测 n 个字母。那么你的错误率就是说，你预测出来这个字母和真实的字母之间，你需要做多少次的修改才能过去。S 就是说你要做多少次替换。D 是说要多少次的删除。然后I 是要做多少次的插入。如果你是完美的的话。那么就是0。假设你100个词，你要修改5次才能过去的话，那你的词错误率就是5%。所以这个词就是越低越好了。</p>
<p>那么回过头来。他发现如果直接去算 Wer。他会发现 Whisper 就比较亏。因为不同的数据集，它的样式会不一样。所以如果你不知道它的样式的话，那么你就比较亏了。比如说一个数据集的标注全是小写的话，那么你做了一个大写，那么你就是有一次的错误在里面。他这里的做法。就是手动做了一个 Normalizer，这个 Normalizer。在真实的应用中它不需要。但是为了评测数据好看一点，他需要去手动的做这个东西。他在 Pendix C 讲了很多这样的细节, 我们大概看一眼。这里列出了他为了刷榜的各种优化。比如说他把方括号里面所有的词删掉, 把原括号里面所有的词删掉, 把这种语气注词如果出现全部删掉, 比如说数字之间的逗号删掉, 然后比如说这种跟钱相关的, 比如说十万美金。改成这样子的一个形式。基本上作者就是看 Whisper 的输出, 跟你的数据集里面的格式有什么区别, 然后手动的加上很多这样子的规则。</p>
<p>这就是实验的设置。3.3 章讲的是英语的语音识别的性能。在开始的一段话。他其实还黑了一下2015年的, Deep Speech 2 这个工作。这个是 Andrew Ng 当时还在百度的时候, 主持的一个工作。Deep Speech 当时的核心思想是用深度学习来做这种端到端的语音识别。也是当时采集的比较大的一些数据。然后效果也是挺好的。然后Deep Speech 2 出来之后。他在文章中非常自信的说。我们的结果那么好, 所以我们觉得。这里根本 就没有什么可以改进的空间。除非你能做更多的 Domain Adaptation。其他的上下文是说。当时 Deep Speech 2 在 Libri Speech, 这一个大家公认的数据上。特别是他在 Test Clean。就是在干净的语音下面。当时他们达到了5.3%的一个错误率。基本上 5.3% 是跟你的人类的错误率很近了。但是比较打脸的是。在之后的几年之后。大家把这个数字降低到 1.4%。所以是远远的低于当时候, 人类的一个5.8%的一个错误率, 所以千万别低估大家的刷榜能力。</p>
<p>但作者讲这个故事。也不是纯为了去黑一下 Deep Speech 2。核心思想就是说。这种做到了 1.4% 的性能。真的是有用吗。所以 图2 就是想去验证这个想法。就是说你在这个数据上刷的再低。也没有太多用。你的 X轴 是你在 Libri Speech 这个干净的数据集上的词错误率, 这个是 1% 到8%。然后你的 Y 轴是在一些别的数据集上, common voice以及说TED, 这个是一个比较长的语音识别数据集上的一个错误率。一个完美的系统是说。它在这个上面有个 4% 的错误率的模型。那么在别的数据集上。也应该是一个 4% 的样子。但实际上是差的还是比较远的。因为毕竟这是比较干净的一个数据集。所以蓝色这个线就是表示的, 在Libri Speech上。所有训练好的这些模型。在别的数据集上的一个表现。可以看到。虽然我可以做到百分之一点几的性能。但是换到别的数据集的话。你的错误率马上就十倍以上了。而反过来讲。Whisper它虽然在Libri Speech上。它的不见得比别人都要低。它大概是2.7的一个错误率。你看别人只低于2.7的。还有一大块在这个地方。所以当你在别人的主场。打不赢别人的时候。你需要拉到一个别的战场来比。它说虽然我不是在上面最低的。但是我的泛化能力是最好的。就是说虽然我这个地方。有百分之2.7的错误率。但是换到别的地方。我也是只有百分之十几。你同样的误差的。它都在百分之三十几的样子。所以这也能理解。因为这个模型并没有。在这个的训练级上进行训练。它在这个上面错误率。纯粹是因为你的数据比较干净。所以错误都比较低。它在这个地方错误比较高, 纯粹是你这个地方比较难一点。错误高。而不是你过多的。拟合了这个数据集。然后这里还有一个。有意思的黄色点说。这是一个人类的一个错误率。它说在Library Speech上。大概是百分之三的错误率。然后在别的地方。大概是百分之十几。所以跟整个Whisper 是比较重合的。但是这是一个人， 我也不知道是谁， 他写的一个 Ilec。我觉得可能就是一作，然后自己标了一下数据，然后看了一下，自己的一个性能。所以这个我觉得，也不能太信了。</p>
<p>就 表2 它对比的是Whisper，和 Wave2Vec 模型的一个能力，就是说整体来讲，说我的要低一点。在各个数据上的。词错误率要更低。</p>
<p>讲完英语的性能之后。它拓展到多语言的。一个语音识别的一个性能。首先它用了两个标准的数据集。然后再跟别的方法比的话， 在这一个 数据集 上，它的效果要好一点。它的错误率是8.1。但是在另外一个数据集上。它错误率要高一点。作者觉得一个原因是说。这个数据集相对来说。比较小数据。所以大家训练都不是很好。这个数据集相对来说。比较大一点。所以在上面的训练集。训练好的模型。可能是比它要好一点。</p>
<p>那么所以还是。如果你主场打不赢的话。那我给你看一些别的。上面这张图演示的是 Whisper的模型，在各个语言上的这个词错误率。然后它的 X 轴是说。每个语言它在我这个训练集里面有多少小时的训练数据。然后你的Y轴是你对应的词错误率。X轴和Y轴都是一个 Log Scale的。所以基本上可以看到是说，当你的数据成倍增长的时候，你的词错误率也是，按比例的往下降。具体来说是，假设你想把你的错误率，往下降一倍。那么你的训练数据集，你需要增加一时六倍。然后看到英语的错误率，是5%。基本上跟人可能是，有点接近了。所以在英语上整个是差不多了。但对别的语言来讲，10%或者40%的话，还是有很大的一个，提升空间。比较有意思的是说。你可以看到这里有几个，做的不是那么好的。就是说虽然我的数据，也不少。但是整个词错误率比较多的。包括了中文、韩语。以及说阿拉伯语。作者觉得这也有两个原因。一个是说。你跟别的语言就长得很不一样。比如说英语、法语、德语。它们可能是可以相互帮忙的。就它的发音上可能是，有一点点的一些联系。比如说都是 西欧那边，过来的语言。你们这些语言的发音。确实是挺不一样的。这是第一点。第二点还是回到了那个Tokenizer。这个Tokenizer呢，确实我觉得设计上。是不那么适合这些语言的。所以针对这三个语。基本上还是有改进的空间。在这个里面。</p>
<p>接下来讲的是翻译。翻译的性能。其实 Whisper 不错。在这个数据集上。它的所有的精度。它其实是比别人要高的。这个是翻译。所以用的是Bluescore。越高越好。然后同样。它又画了一个这样的图。讲述的是每一个语言。它所有对应的翻译的小时数。然后它的Bluescore。有意思的是。韩语在这个里面是比较多的。应该是有几万个小时吧。很有可能是它们抓了很多韩剧。Netflix 上韩剧比较多。它很有可能是把 Netflix。给你抓下来了。虽然它的数据还是挺多的。但是它的 Bluescore。比中微线是要差一些的。</p>
<p>接下来是一个语言的。识别的一个能力。Whisper在上面倒是。做的是一般般。就是比两个对比的算法。其实都是要差一些的。在你的语音信号里面。加噪音。使得你的 信噪比 往下降的时候。你整个词的错误率。这个是Whisper的性能。基本上它的信噪比 。在15的时候还是不错的。这个地方是不一样的噪音。这个地方也是15的时候。是不错的。但是它不是最好的。就是说这些方法。效果比它好一些。原因还是。这是 Libri 这个数据。剩下这些方法。在上面训练好的话。那么整个你的词错误率。本来就是要比 Whisper要低的。</p>
<p>然后 图6 对比的是Whisper。和别人在比较长的。这些数据集上的对比。这里一共有7个数据集。它对比了4家公司。和 NVIDIA 开源的一个软件。这个用的还是挺多的。4家公司没有讲是谁。基本上你可以认为。是Google。微软。Amazon。或者是另外一家。别的做语音的公司。这个是一个 Blocks Plot。中间这个线。表示的是它的中值。然后上面应该是一个95%。以及5%的一个Quantile。然后在上面， 这是一些Outlier。基本上你看一下中值。和这个有多宽就行了。基本上可以看到。在这些数据集上。Whisper表现还是挺不错的。基本上跟商业的系统。打的有来有回。要比这两个差一点。比这两个好一点。比这两个差一点。比这两个稍微好一点。然后比开源的系统。整体来讲是要好一些的。所以基本上是一个。可用的状态。我们上一个视频。它的字幕也是。纯用 Whisper 出来的。看过觉得怎么样。应该还是能够看的。所以这也给这些商业的 API。带来了很大的挑战。因为你调用他们的API。是要付钱的。而且也不是很便宜。现在你可以下载它。然后自己付点电费。就能跑了。所以应该还是一个，搅局者的身份出现吧。然后 图7 主要的卖点是说。Whisper在几个数据集上。它的词错误率，是跟这些专业的，帮你做转录的这些平台上的，人的性能是差不多的。这个是四个不同的平台上，人对这些数据集上的。一个词错误率。基本上你是8.76。这也是8.14 8.65。虽然这两个比这么好一点。这两个差一点。基本上是一个打平的状态。所以基本上 Whisper 。也给这些专业的。做转录的这些服务商。也算是一个沉重的打击了。好的 这个就是第三节。</p>
<p>接下来的第四章。就是对模型的一些。设计上的一些分析了。第四点一节讲的是模型。变大的一个效果。他说在弱监督学习里面。一个承诺是说。你可以用比较大的。一个数据集。但是如果你这个数据集。比你这种 Golden Standard，这种标注比较好的数据集相比。你的噪音如果更多的话或者说你的质量更低的话。有可能会对你的模型产生影响，使得你反而训练的模型效果更差了。所以这个带来的一个问题。是说当你的模型。变得很大的时候。你的模型可能就是把你。这个数据全部记住了。而且你的数据。如果质量不是很高的话。他可能记住的不是。一些什么好东西。</p>
<p>所以接下来的图8。就是讲的是。帮你的模型变大的时候。你在的数据集上的。一个效果。首先看到这是英语的。语音的识别。当你的模型。从最小的Tiny 38兆。变到了最大的时候。基本上看到是有一个下降的。所以这个不同的曲线应该是不同的数据集上的一个效果。然后呢这是一个平均的效果。基本上，降到Medium。就是7个亿的规模的时候还是有下降。但是最后的一点点。是有一点点饱和的迹象。但是至少没有往上翘。对吧。接下来是一个。多语言的语音识别。整体来看。它还是在下降的。跟英语相比。它的下降趋势。更加明显一点。应该是。当你模型很大的时候。你对别的语言。可能表现还是不是那么好。因为你的数据集。相对来说还是比较少一点。比如说里面还有中文。韩语这种比较。很不一样的语言。它的效果。其实可能。训练还是不够的。这张图来讲的是。你翻译的一个效果。也是一个上升。最后一个图讲的是。语言识别的一个效果。也是随着模型的增大。它的精度也是有所提升的。所以至少在这张图里面。可以看到。虽然我的模型变大了。我对数据的拟合更好了。但是它是 zero short。就是说它是在别的数据集上。看到的整个效果。还是基本上是一个下降趋势。虽然有些线是往上增的。比如说这个线是往上跑的。但是整体的趋势还是可以的。</p>
<p>4.22节讲的是。帮你的数据变大的时候。的一个效果。可以看到在这个地方。当你把数据集的小时数。从3000小时。一直涨到68万小时的时候。整个的趋势是这样子。我虽然不理解。为什么他用表。不是用之前那个图。但是可以看到是说。英语的提升，在前面的还是比较明显。在后面的话。比如说从5万小时提升到。68万小时。十几倍的提升的时候。其实这个涨的点是比较少的。证明英语在前面。基本上是比较饱和了。但是在多语言。跟我们之前看到的一样。还是有比较大的一个提升。以及机器翻译。机器翻译也是在最后。也是做了一个比较大的提升。所以整体可以认为。英语的语音识别。相对来说在这里面。算是比较容易的一个任务。别的语言的以及翻译的。感觉更加难一点。所以需要的数据量。会更加大一点。</p>
<p>4.33讲的是。多任务和多语言的迁移的一个效果。它在下面的图展示的是说。X轴 是计算的FLOPS数。就是你基本上可以认为。我训练了多少个样本。这个是一个指数级的上升的一个过程。你的Y轴是一个， 平均下来十一个英语语音识别上任务的一个， 平均的一个词错误率。蓝色这个线是表示说。我的语料里面只有英语。没有用别的语言。也没有用翻译。基本上可以看到。它也是一个下降的过程。黄色这个表示是。英语的语音识别。也只用了65%。剩下的35%的样本。是在做别的语言的。一个语音识别。或者是一个翻译的任务。可以看到是说。当你的训练，在比较前期的时候。就是你的计算资源。没那么多的时候。你尽量的  只看英语语音。的话效果好一点。但是一旦当你的训练。时间够长的时候。这种多语言和多任务的。效果反而会更加好一点。我感觉这个应该就是说。你训练到这个地方的时候。你可能看了几遍数据了，两遍或者三遍数据。如果你只使用。英语语音识别的话。那么你的数据。其实是多样性会少一点。如果你使用了。一些别的任务的话。因为你看的数据。本身就多一点。所以在大家都看了。一两遍数据的情况下。数据的多样性。可能对你来说。更加重要一点。而且这种别的语言。的语音识别。和语音到英语的。翻译的任务。应该也是或多或少。能帮助英语的语音的识别。</p>
<p>第4.4节讲的是。文本的归一化。我们之前有提到。它为了去刷榜。它需要把Whisper。出来的结果。再做一次归一化。使得它跟别的数据集的。格式比较一样。那么作者就问说。这个格式我们其实是。根据你的测试集。来弄出来的。是不是有一点。overfitting在里面了。然后这个地方。它比较的是说。Whisper模型。和Open Source的模型。都用它们做出来。那一个文本归一化的效果。然后把它们自己做的。那一个文本归一化的函数。换成了 FairSpeech 的那个Normalizer相比。X轴表示的是。他们做出来的。这个Normalizer。比 FairSpeech 的 Normalizer 要好多少。可以看到。在这几个数据集上。基本上是一个。差不多的效果。当然他们的效果应该是好一点。因为它都是在零以下。这是它的一个。词错误率的下降。特别对这几个数据集。好处是比较明显的。对 Open Source 的模型。好处好像少一点点。但是对于他们。自己的模型。Whisper是没有做 Normalization的。直接是裸出的话。所以用上这个效果。会效果更加明显一些。</p>
<p>最后一节讲的是说。怎么样做比较长的。这种语音的识别。所谓的比较长的。语音识别。通常是几分钟。甚至是一个小时以上。但是它的模型。因为每一次只处理。30 秒 的这种语音数据。所以你需要做多次。但是做多次的话。它的误差容易累加。在这个地方。它们做了比较多的。一些这样子的优化。首先它们用了 Bean Search。就是束搜索。用了5个Bean。意味着说。当前总是维护。5个最好的一个选项。它做这个的主要目的是。它想去避免 这个 Repetition Looping 。这个东西其实。发现还是挺常见的。比如说这个是网上。同学们总结出来的。Whisper 出错的一些样例。这个是你真实的标号。这个是Whisper出来的效果。这个就是做。for for for for 就是一个Looping。就是重复的把一些重复的词生出来。这个其实我发现在我的使用中也经常出现。它这里的一个解决办法, Softmax的那个温度。当你的温度是0的时候。它把每一个值。它预测的概率。就分得比较开。如果分得比较开的话。比如说我当前是For。下一个预测。还是For的概率。可能是0.9。那么我就选了For了。别的我基本上就不会选了。在这个的情况下。你一个办法是说。你把你的温度增加。就增加0.2就表示说。把每一个词之间的。那些概率的差异。拉平一点。这样子因为你。取了5个束搜索。所以你可能选到。一个别的词的概率。就会变高了。你的多样性就会增加。当增加多样性。也可能带来你选出来的。结果的质量。可能就变差了。可能选了一些。很奇怪的东西出来。那么它这里的。一个规则是说。如果在过去, 你的 log 的概率。就是你的概率做log, 它就变成一个负数。在之前的这些词上面。是比 -1 要小的情况下。或者你生成的这些文字。如果用 gzip 压缩一下。压缩率是比 2.4 要高。所谓的压缩率 比2.4要高。就等于是说。你这里面没什么东西。所以很容易。被压缩的情况下。它就把你这个温度。增高一点。这样子增加多样性。另外一个是。当你的温度。是小于0.5的时候。它把你上一个时间窗。就是上一个30秒里面的。转录出来的文字。作为一个前面的文字。放进来。就是我们回忆一下。我们在之前讲的时候。你可以在翻译。当前的句子的时候。把前面的句子。作为一个前提放进去。另外是关于没有说话的这些片段的一个识别。它发现。如果你就去判断说。我当前的输出是。no speech这个token的话。好像也不是那么的准。所以它的一个办法是说。当你输出这一个。没有说话的词的概率。是大于0.6的时候。而且在过去的这些。token上的预测。它的 log 的概率。是小于 -1 的时候。就表示过去那些词的。执行度都比较高的情况下。那么你就认为。这个段是没有说话的。最后还有一点是说。它这个模型。好像会把前面的这些词。或者是最后的这些词。给你丢掉。所以在这里的解决办法。它是说我的，第一个片段的开始，一定是在前面的一秒钟以内。就避免说我前面的段落，你不给我去转录。就算是没有说话，你也应该去转录。表七段讲的是说。跟你的基线。就是做贪婪的搜索相比。加上所谓这些规则。对你这些比较长的数据集的语音转录的一个区别。可以看到你的词错误率是从平均11降到了10。好 这个就是第四章。</p>
<p>第五章讲的是相关的工作。但我们在语音这一个系列。其实没有讲过前面的文章。所以我们就跳过去了。</p>
<p>我们直接看一下。作者提到了Whisper的一些，限制性在什么地方。首先看到是关于解码器，所谓的解码器。就是你最后输出的。结果的一个好坏。因为你对编码器的编码。你很难去衡量它的好坏。但是解码器。就是跟你的 Ground Truth 相比。它首先肯定说。当你的模型变大的时候。你对一些词的选择上会更加好一点。因为很多词的发音其实是一样的。特别是中文, 它可以根据你的上下文。去找出最合适的那一个词。当你模型越大的时候。这一块就做得越好。我也感觉到。当你用 Large 的时候。在有些词的选择上。确实会更加准确一些。但是还是有很多噪音。特别是比较长的。这种语音转读的时候。错误率还是比较高一点。然后它说这个语音, 可能来自于很多地方。一个是你的。Sequence to Sequence的模型。你的语言模型。以及说你的文本。和语音的一个对齐。所以核心就是 Debug 是比较难的一件事情。然后作者就随便说了一句话, 他说我们觉得可能。你再找一个质量, 更高一点的数据集再在上面fine tune 一下, 可能会效果好一点。当然任何话你都可以这么说, 反正你结果不好, 你就怪数据集嘛。第二个是说, 对于这种语料不足的语言。增加它的训练数据。因为很多语言，它其实在里面可能含有少于一千个小时的训练数据。这个东西你怎么办呢。其实你最好是去找一点电影。因为电影我觉得。对于小语种的电影。可能还是能找出一些来的。甚至很多电影，它可能是有小语种的配音。你应该是可以在里面。挖掘很多东西出来。</p>
<p>然后是说。你要去做 fine tuning。我觉得这个。它也是随便写一写。它前面的卖点。主要是说。我这么做  的话。我不需要做fine tuning。现在我要做一做fine tuning。这样子可能。跟别人比。效果会更加好一点。</p>
<p>然后还有一个是说。我能调一调我的架构。regulation augmentation。就是它的架构没怎么动。基本就transformer过来。实际上 transformer 在。目前看上去。好像在语音数据上。不一定是最好的一个架构。现在大家用的。比较多的是 conformer。就是在 transformer 里面。再加了一点卷积进来。这是 Google 之前的一个工作。加一点归一化。加 augmentation。它们是没有加。任何 augmentation 的。就是说它的数据。是直接拿进来做。没有做任何的。一个数据的增强。主要是因为它的数据。应该多样性够了吧。反正在网上抓来。那么大数据。因为一旦你做 augmentation 的话。你得花更多的算力。所以你还不如去依赖 数据本身的一些多样性在这个里面。</p>
<p>最后一个是说。加一点辅助的。训练的目标函数。因为这个地方。它就是一个。标准的语言模型。没有做任何的。别的损失。所以它说我是不是。可以加点别的。</p>
<p>这一张我觉得写的。不是特别有诚意。基本上是说。我没有东西。我都往上面写一写。然后希望可能。别人未来会，接着这个往下做。但我觉得这个事情。可能 fine tuning。虽然好一点点。但是你别的那些东西。真的不好做。因为别人没。你的训练集。甚至有了你的数据集。也不是每个人。都有那么大的算力来训练。这样子的模型的。</p>
<p>这就是Whisper。这篇论文。我们接下来给大家。做一个总结。和一个讨论。Whisper这篇文章。在讲一个。什么样的故事呢。只要我有足够多的。带有标注的数据。以及有足够的算力的话。那么我可以不在模型上做任何优化。也跟别人，要么就是说。你有更多的数据。但是没有标号。或者是说。你在模型的。各种技术上。细节打满。相比我也不会输。我甚至可能会。在某些地方。更好一些。这个结论其实。听上去一点。不意外。十年前我们也知道。只要你数据够多的话。不管是 SVN。还是什么。树 的模型。还是神经网络。可能差别。都不是那么的大。你去读论文。看到说。我在这个模型上。改一下这个。改一下那个。在这个数据上。比之前的要好。那么一点点。但是在比你。高一个量级的。数据的前面。你这些改动。可能都是没用的。比如说15年。比如说15年前。我当时还在。百度广告团队。做模型的时候。那个时候。大数据。那个热潮刚刚兴起。但是公司里面。大家也用几十 TB 的数据。已经很正常了。那时候我就尝试了。基本上 ICMA。NURBS。所有这些优化算法的。这些新的算法。我发现在这大数据前面。大家都没什么区别。大家都长一样。所以这些文章。都是没有太多用的。所以这篇文章。核心还是证实了这一点。但是它的主要的意义。在于说。它是第一次。在语音识别这个领域。告诉大家说。这个也是能行得通的。我觉得这件事情的。影响力会是比较大的。是因为语音这个东西。大家都需要。不管你是做手机的。做车载系统的。还是做这种视频平台的。或者说做智能设备的。它都需要跟这种语音。打交道。你如果是这样子的公司。你有什么选择。你要么就是说。调用比较成熟的。语音服务的API。就相信他们做得比较好。但是他们这种API。不见得是对你的。应用场景做优化了。比如说我就是要。室内的这种说话的识别。或者我就是。B站上这种。视频的语音的识别。里面可能带了很多背景音乐的。但另外一个方法是说。你在你的数据上。训练自己的模型。但是这也会带来说。你可能会觉得说。我没有语音的专家。或者说。我可能觉得。自己训练的模型。效果没有人家。专业的做的东西的效果好。那么Whisper这篇文章。告诉你说。其实你是可以做到的。只要你有足够多的数据和足够多的算力。这两件事情。都不是很难解决。算力这个东西就是换成钱。因为钱这个东西，大家都多少多少。都会有一些。对于一个公司来讲。你咬咬牙。只要你觉得语音。这个事情重要的话。你应该是能咬出牙来。拿出那么多算力的。数据上来。也没有太多技术含量。OPENAI 没有自己的数据。它也是在网上爬的。爬数据这个事情。没有那么难。我觉得绝大部分同学。是能够去爬这个数据的。而且做数据的清理。看上去也算是比较简单。所以这一块。真正的门槛。是语音的专家。因为语音它其实也是。一个比较小的领域。每一年能够毕业的学生。也就那么多。对于一个公司来讲。你想招到特别好的。语音方面的专家。其实是一件很难的事情。不是用钱就能换过来的。比如说几年前。小米当时候招到了 Kaldi。一个非常流行的语音的工具包的作者, 当时还是很大的新闻。但 Whisper 这篇文章。告诉你说。你就就去 hugging face 上找一个已经实现好的模型。你也没有什么多的。trick可以用的。就是你不需要。在语音上面有十年的积累。或者读过很多文章。或者做过什么事情。你就把它拿下来。在足够的数据和算力面前。这些东西都可以弥补。所以真的能够。降低整个的门槛。我觉得这个是一个。影响力非常大的事情。比如说 B 站在去年。应该是做了一个。自动的做字幕的一个服务。我当时还用了几次。后来发现。如果我的说话里面。带英语的话。我们这种视频里面。肯定会带英语的话。这种专业的名词。它的识别非常糟糕。而且是比较可笑的。特别影响观感。所以我就停掉了。前几天我就跟 B站 同学说。你们应该试试。Whisper这个模型。你把这个模型下下来。在B站上所有的数据上。再做一次fine tuning。那么效果应该是。会比较好的。B站同学说。这个可以马上去弄。</p>
<p>说完好的地方。再说一下。我觉得这个工作。有些不足的地方。第一点是说。它的计算还是太贵了。因为作者并没有。在模型上面做什么优化。它的代码也没有。做过优化。所以你先别说训练吧。就算是做预测。它的算力要求也是非常高的。我们在上一个视频里。讲过一分钟的视频。你在CPU上。可能要花个两分钟，三分钟。我觉得这个是。比较难以忍受的。但我觉得这个补习个硬伤。未来应该会看到什么。efficient whisper。这样子的工作出来。把你的算力往下降。第二个是来自于它的效果。我觉得它收集到的数据。应该是比较好的。这一些数据。就是说整个人。至少说话是流畅的。你又可以是背景有噪音。但是呢。说话应该不是。这种磕磕巴巴的。你像我上一期。用它来做一个。剪视频的工具。主要是剪。我讲的磕磕巴巴的。这种视频。它的效果就会差很多。比如说一个视频里面。大量停的。或者大量的口误。这个这个那个那个的时候。它每一次去看一个。30秒钟的窗口。它的每一个词的识别。应该是跟上下文。很相关的。如果上下文都是一些。这种口误的词。或者是一些空白的话。其实会影响到一个完整句子的一个转录的性能。而且经常可以看到。是说。我说。其实其实是什么样子。就前面第一个词。其实是说错了。但是呢。它把两个其实是。可能不一定会。给你识别出来。它可能就识别出一个。就吞掉了前面一个词。这个东西都会。至少在我剪视频的。这个上面。会有一点困难。它不能把我这个口误。给你摘出来的话。那我时候可能。还是得过一遍。如果偷懒。不去过的话呢。那么你的视频里面。就会多了一些。听上去不那么舒服的。一些口误词在里面了。当然这个也是有。解决方案。我可以在上面。再加一个小的分类器。把那些我觉得。明显的口误的片段。剪掉也就行了。最后一个是。它没有公布。自己的训练数据。甚至没有讲。它数据是什么。所以这个会给。想重复他们工作的人。带来一些困扰。但是我们在视频里面。也讲过。就是说你多多少少。也知道他们。一时用了什么数据。所以你就去爬。这些数据就行了。我觉得呢。有能力和有时间。同学可以去。干这个事情。比如说你想一想。你平常去什么地方。看电影。听音乐。或者听什么东西。你去看一看。这个地方的东西。能不能爬下来。在存储上面的成本。也不是问题。可以看我们前几期。讲到说。怎么样装一个100TB。或者500TB的存储的方案。我觉得用来存。这些爬的数据。应该是问题不大。大不了就说。你把视频丢掉。只剩下音频就行了。如果你真干这个事情。别来找我。我还是比较怕。被查水表的。</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"></nav></div></div></div></div></main></div></div></div></div>
</body>
</html>