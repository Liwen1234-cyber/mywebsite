<!doctype html>
<html lang="en" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-码农/刷题记录/图论" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.7.0">
<title data-rh="true">图论 | Coisini</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:url" content="https://doc.minddiy.top/码农/刷题记录/图论/"><meta data-rh="true" property="og:locale" content="en"><meta data-rh="true" name="docusaurus_locale" content="en"><meta data-rh="true" name="docsearch:language" content="en"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="图论 | Coisini"><meta data-rh="true" name="description" content="图的基本概念"><meta data-rh="true" property="og:description" content="图的基本概念"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://doc.minddiy.top/码农/刷题记录/图论/"><link data-rh="true" rel="alternate" href="https://doc.minddiy.top/码农/刷题记录/图论/" hreflang="en"><link data-rh="true" rel="alternate" href="https://doc.minddiy.top/码农/刷题记录/图论/" hreflang="x-default"><meta name="google-site-verification" content="1FUPX6Qo4y3ecU623ShEurhgnjhSTjK49rRMhEDlzFA">
<link rel="stylesheet" href="/katex/katex.min.css">
<script src="/js/matomo.js" async defer="defer"></script><link rel="stylesheet" href="/assets/css/styles.79037026.css">
<script src="/assets/js/runtime~main.468f2b27.js" defer="defer"></script>
<script src="/assets/js/main.4763ab3e.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return window.localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const n=new URLSearchParams(window.location.search).entries();for(var[t,e]of n)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="Skip to main content"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">Skip to main content</a></div><nav aria-label="Main" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="Toggle navigation bar" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="Chialisp Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">Coisini</b></a></div><div class="navbar__items navbar__items--right"><a href="https://minddiy.top" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">Main site<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="Switch between dark and light mode (currently light mode)" aria-label="Switch between dark and light mode (currently light mode)" aria-live="polite" aria-pressed="false"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"><div class="navbar__search searchBarContainer_NW3z" dir="ltr"><input placeholder="Search" aria-label="Search" class="navbar__search-input" value=""><div class="loadingRing_RJI3 searchBarLoadingRing_YnHq"><div></div><div></div><div></div><div></div></div></div></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="Scroll back to top" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><main class="docMainContainer_TBSr docMainContainerEnhanced_lQrH"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">On this page</button></div><div class="theme-doc-markdown markdown"><header><h1>图论</h1></header>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="图的基本概念">图的基本概念<a href="#图的基本概念" class="hash-link" aria-label="Direct link to 图的基本概念" title="Direct link to 图的基本概念">​</a></h2>
<p>二维坐标中，两点可以连成线，多个点连成的线就构成了图。</p>
<p>当然图也可以就一个节点，甚至没有节点（空图）</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="图的种类">图的种类<a href="#图的种类" class="hash-link" aria-label="Direct link to 图的种类" title="Direct link to 图的种类">​</a></h3>
<p>整体上一般分为 有向图 和 无向图。</p>
<p>加权有向图，就是图中边是有权值的，加权无向图也是同理</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="度">度<a href="#度" class="hash-link" aria-label="Direct link to 度" title="Direct link to 度">​</a></h3>
<p>无向图中有几条边连接该节点，该节点就有几度。在有向图中，每个节点有出度和入度。出度：从该节点出发的边的个数。入度：指向该节点边的个数。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="连通性">连通性<a href="#连通性" class="hash-link" aria-label="Direct link to 连通性" title="Direct link to 连通性">​</a></h3>
<p>在图中表示节点的连通情况，我们称之为连通性。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="连通图">连通图<a href="#连通图" class="hash-link" aria-label="Direct link to 连通图" title="Direct link to 连通图">​</a></h3>
<p>在无向图中，任何两个节点都是可以到达的，我们称之为连通图，如果有节点不能到达其他节点，则为非连通图</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="强连通图">强连通图<a href="#强连通图" class="hash-link" aria-label="Direct link to 强连通图" title="Direct link to 强连通图">​</a></h3>
<p>在有向图中，任何两个节点是可以相互到达的，我们称之为强连通图。强连通图是在有向图中<strong>任何两个节点是可以相互到达</strong></p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="连通分量">连通分量<a href="#连通分量" class="hash-link" aria-label="Direct link to 连通分量" title="Direct link to 连通分量">​</a></h3>
<p>在无向图中的<strong>极大连通子图</strong>称之为该图的一个连通分量。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="强连通分量">强连通分量<a href="#强连通分量" class="hash-link" aria-label="Direct link to 强连通分量" title="Direct link to 强连通分量">​</a></h3>
<p>在有向图中极大强连通子图称之为该图的强连通分量。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="图的构造">图的构造<a href="#图的构造" class="hash-link" aria-label="Direct link to 图的构造" title="Direct link to 图的构造">​</a></h2>
<p>一般使用邻接表、邻接矩阵或者用类来表示。主要是朴素存储、邻接表和邻接矩阵。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="邻接矩阵">邻接矩阵<a href="#邻接矩阵" class="hash-link" aria-label="Direct link to 邻接矩阵" title="Direct link to 邻接矩阵">​</a></h3>
<p>邻接矩阵 使用 二维数组来表示图结构。 邻接矩阵是从节点的角度来表示图，有多少节点就申请多大的二维数组。</p>
<p>例如： <code>grid[2]][5] = 6</code>，表示 节点 2 连接 节点 5 为有向图，节点 2 指向 节点 5，边的权值为 6。如果想表示无向图，即：<code>grid[2][5] = 6</code>，<code>grid[5][2] = 6</code>，表示节点 2 与 节点 5 相互连通，权值为 6。</p>
<p>在一个 n （节点数）为 8 的图中，就需要申请 8 * 8 这么大的空间。</p>
<p>邻接矩阵的优点：</p>
<ul>
<li>表达方式简单，易于理解</li>
<li>检查任意两个顶点间是否存在边的操作非常快</li>
<li>适合稠密图，在边数接近顶点数平方的图中，邻接矩阵是一种空间效率较高的表示方法。</li>
</ul>
<p>缺点：</p>
<ul>
<li>遇到稀疏图，会导致申请过大的二维数组造成空间浪费 且遍历 边 的时候需要遍历整个 n * n 矩阵，造成时间浪费</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="邻接表">邻接表<a href="#邻接表" class="hash-link" aria-label="Direct link to 邻接表" title="Direct link to 邻接表">​</a></h3>
<p>邻接表 使用 数组 + 链表  的方式来表示。 邻接表是从边的数量来表示图，有多少边 才会申请对应大小的链表。</p>
<p>邻接表的构造如图：</p>
<p><img decoding="async" loading="lazy" alt="20241208_120929_473_copy" src="/assets/images/20241208_120929_473_copy-c43c0aaed2c8fb05c668cc7cc21e4768.png" width="988" height="760" class="img_ev3q"></p>
<p>这里表达的图是：</p>
<ul>
<li>节点 1 指向 节点 3 和 节点 5</li>
<li>节点 2 指向 节点 4、节点 3、节点 5</li>
<li>节点 3 指向 节点 4</li>
<li>节点 4 指向节点 1</li>
</ul>
<p>邻接表的优点：</p>
<ul>
<li>对于稀疏图的存储，只需要存储边，空间利用率高</li>
<li>遍历节点连接情况相对容易</li>
</ul>
<p>缺点：</p>
<ul>
<li>检查任意两个节点间是否存在边，效率相对低，需要 O(V)时间，V 表示某节点连接其他节点的数量。</li>
<li>实现相对复杂，不易理解</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="图的遍历方式">图的遍历方式<a href="#图的遍历方式" class="hash-link" aria-label="Direct link to 图的遍历方式" title="Direct link to 图的遍历方式">​</a></h2>
<p>图的遍历方式基本是两大类：</p>
<ul>
<li>深度优先搜索（dfs）</li>
<li>广度优先搜索（bfs）</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="dfs-基础知识">DFS 基础知识<a href="#dfs-基础知识" class="hash-link" aria-label="Direct link to DFS 基础知识" title="Direct link to DFS 基础知识">​</a></h2>
<p>DFS 关键就两点：</p>
<ul>
<li>搜索方向，是认准一个方向搜，直到碰壁之后再换方向</li>
<li>换方向是撤销原路径，改为节点链接的下一个路径，回溯的过程。</li>
</ul>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="代码框架">代码框架<a href="#代码框架" class="hash-link" aria-label="Direct link to 代码框架" title="Direct link to 代码框架">​</a></h2>
<p>正是因为 dfs 搜索可一个方向，并需要回溯，所以用递归 的方式来实现是最方便的。</p>
<div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token keyword" style="color:hsl(301, 63%, 40%)">void</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">参数</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    处理节点</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token function" style="color:hsl(221, 87%, 60%)">dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">图，选择的节点</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 递归</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    回溯，撤销处理结果</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="98-所有可达路径">98. 所有可达路径<a href="#98-所有可达路径" class="hash-link" aria-label="Direct link to 98. 所有可达路径" title="Direct link to 98. 所有可达路径">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1170" target="_blank" rel="noopener noreferrer">卡码网题目链接（ACM 模式）</a></p>
<p>【题目描述】</p>
<p>给定一个有 n 个节点的有向无环图，节点编号从 1 到 n。请编写一个函数，找出并返回所有从节点 1 到节点 n 的路径。每条路径应以节点编号的列表形式表示。</p>
<p>【输入描述】</p>
<p>第一行包含两个整数 N，M，表示图中拥有 N 个节点，M 条边</p>
<p>后续 M 行，每行包含两个整数 s 和 t，表示图中的 s 节点与 t 节点中有一条路径</p>
<p>【输出描述】</p>
<p>输出所有的可达路径，路径中所有节点的后面跟一个空格，每条路径独占一行，存在多条路径，路径输出的顺序可任意。</p>
<p>如果不存在任何一条路径，则输出 -1。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// 邻接矩阵</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    static List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    static List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner in = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = in.nextInt(); // 节点</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = in.nextInt(); // 边</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] graph = new int[N+1][N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph[s][t] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        path.add(1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dfs(graph, 1, N);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(result.size() == 0) System.out.println(-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(List&lt;Integer&gt; p : result){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                for(int i = 0; i &lt; p.size()-1; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    System.out.print(p.get(i) + &quot; &quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                System.out.println(p.get(p.size()-1));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        in.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static void dfs(int[][] graph, int x, int n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(x == n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            result.add(new ArrayList&lt;&gt;(path));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(graph[x][i] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                path.add(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dfs(graph, i, n);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                path.remove(path.size()-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// 邻接表</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    static List&lt;Integer&gt; path = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    static List&lt;List&lt;Integer&gt;&gt; result = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner in = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = in.nextInt(); // 节点</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = in.nextInt(); // 边</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;LinkedList&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;(N+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt;= N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.add(new LinkedList&lt;&gt;());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.get(s).add(t);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        path.add(1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dfs(graph, 1, N);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(result.size() == 0) System.out.println(-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(List&lt;Integer&gt; p : result){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                for(int i = 0; i &lt; p.size()-1; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    System.out.print(p.get(i) + &quot; &quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                System.out.println(p.get(p.size()-1));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        in.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static void dfs(List&lt;LinkedList&lt;Integer&gt;&gt; graph, int x, int n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(x == n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            result.add(new ArrayList&lt;&gt;(path));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i : graph.get(x)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            path.add(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dfs(graph, i, n);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            path.remove(path.size()-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="bsf-基础知识">BSF 基础知识<a href="#bsf-基础知识" class="hash-link" aria-label="Direct link to BSF 基础知识" title="Direct link to BSF 基础知识">​</a></h2>
<p>广搜的搜索方式就适合于解决两个点之间的最短路径问题。</p>
<p>因为广搜是从起点出发，以起始点为中心一圈一圈进行搜索，一旦遇到终点，记录之前走过的节点就是一条最短路。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="99-岛屿数量">99. 岛屿数量<a href="#99-岛屿数量" class="hash-link" aria-label="Direct link to 99. 岛屿数量" title="Direct link to 99. 岛屿数量">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1171" target="_blank" rel="noopener noreferrer">卡码网题目链接（ACM 模式）</a></p>
<p>题目描述：</p>
<p>给定一个由 1（陆地）和 0（水）组成的矩阵，你需要计算岛屿的数量。岛屿由水平方向或垂直方向上相邻的陆地连接而成，并且四周都是水域。你可以假设矩阵外均被水包围。</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// DFS</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner in = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] arr = new int[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                arr[i][j] = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        in.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int count = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[][] visited = new boolean[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(!visited[i][j] &amp;&amp; arr[i][j] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    count++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    visited[i][j] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dfs(visited, i, j, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(count);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void dfs(boolean[][] visited, int x, int y, int[][] arr){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int k = 0; k &lt; 4; k++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int next_x = x + dir[k][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int next_y = y + dir[k][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(next_x &lt; 0 || next_x &gt;= arr.length || next_y &lt; 0 || next_y &gt;= arr[0].length)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(!visited[next_x][next_y] &amp;&amp; arr[next_x][next_y] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                visited[next_x][next_y] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dfs(visited, next_x, next_y, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// BFS</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner in = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] arr = new int[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                arr[i][j] = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        in.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int count = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[][] visited = new boolean[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(!visited[i][j] &amp;&amp; arr[i][j] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    count++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    bfs(visited, i, j, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(count);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void bfs(boolean[][] visited, int x, int y, int[][] arr){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue.add(new int[]{x,y});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        visited[x][y] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!queue.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur_x = queue.peek()[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur_y = queue.poll()[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int k = 0; k &lt; 4; k++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int next_x = cur_x + dir[k][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int next_y = cur_y + dir[k][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(next_x &lt; 0 || next_x &gt;= arr.length || next_y &lt; 0 || next_y &gt;= arr[0].length)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(!visited[next_x][next_y] &amp;&amp; arr[next_x][next_y] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    queue.add(new int[]{next_x,next_y});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    visited[next_x][next_y] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="01-孤岛的总面积">01. 孤岛的总面积<a href="#01-孤岛的总面积" class="hash-link" aria-label="Direct link to 01. 孤岛的总面积" title="Direct link to 01. 孤岛的总面积">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1173" target="_blank" rel="noopener noreferrer">卡码网：101. 孤岛的总面积</a></p>
<p>题目描述</p>
<p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的  区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p>
<p>现在你需要计算所有孤岛的总面积，岛屿面积的计算方式为组成岛屿的陆地的总数。</p>
<p>输入描述</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。之后 N 行，每行包含 M 个数字，数字为 1 或者 0。</p>
<p>输出描述</p>
<p>输出一个整数，表示所有孤岛的总面积，如果不存在孤岛，则输出 0。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// DFS</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int count = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner in = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] arr = new int[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                arr[i][j] = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        in.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 从左边界和右边界向中间遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(arr[i][0] == 1) dfs(i, 0, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(arr[i][M-1] == 1) dfs(i, M-1, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // 从上边界和下边界向中间遍历</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int j = 0; j &lt; M; j++){ // 遍历上侧和下侧边界</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(arr[0][j] == 1) dfs(0, j, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(arr[N-1][j] == 1) dfs(N-1, j, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        count = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(arr[i][j] == 1) dfs(i, j, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(count);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void dfs(int x, int y, int[][] arr){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        arr[x][y] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        count++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; 4; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int newX = x + dir[i][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int newY = y + dir[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(newX &lt; 0 || newX &gt;= arr.length || newY &lt; 0 || newY &gt;= arr[0].length)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(arr[newX][newY] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dfs(newX, newY, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// BFS</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int count = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner in = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] arr = new int[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                arr[i][j] = in.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        in.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){ // 遍历左侧和右侧边界</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(arr[i][0] == 1) bfs(i, 0, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(arr[i][M-1] == 1) bfs(i, M-1, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int j = 0; j &lt; M; j++){ // 遍历上侧和下侧边界</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(arr[0][j] == 1) bfs(0, j, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(arr[N-1][j] == 1) bfs(N-1, j, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        count = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(arr[i][j] == 1) bfs(i, j, arr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(count);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void bfs(int x, int y, int[][] arr){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Queue&lt;int[]&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        count++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue.add(new int[]{x,y});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        arr[x][y] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!queue.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur_x = queue.peek()[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur_y = queue.poll()[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int k = 0; k &lt; 4; k++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int next_x = cur_x + dir[k][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int next_y = cur_y + dir[k][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(next_x &lt; 0 || next_x &gt;= arr.length || next_y &lt; 0 || next_y &gt;= arr[0].length)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(arr[next_x][next_y] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    count++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    queue.add(new int[]{next_x,next_y});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    arr[next_x][next_y] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="102-沉没孤岛">102. 沉没孤岛<a href="#102-沉没孤岛" class="hash-link" aria-label="Direct link to 102. 沉没孤岛" title="Direct link to 102. 沉没孤岛">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1174" target="_blank" rel="noopener noreferrer">卡码网题目链接（ACM 模式）</a></p>
<p>题目描述：</p>
<p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿指的是由水平或垂直方向上相邻的陆地单元格组成的区域，且完全被水域单元格包围。孤岛是那些位于矩阵内部、所有单元格都不接触边缘的岛屿。</p>
<p>现在你需要将所有孤岛“沉没”，即将孤岛中的所有陆地单元格（1）转变为水域单元格（0）。</p>
<p>输入描述：</p>
<p>第一行包含两个整数 N, M，表示矩阵的行数和列数。</p>
<p>之后 N 行，每行包含 M 个数字，数字为 1 或者 0，表示岛屿的单元格。</p>
<p>解答：</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="dfs">DFS<a href="#dfs" class="hash-link" aria-label="Direct link to DFS" title="Direct link to DFS">​</a></h4>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.Scanner;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] grid = new int[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for (int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                grid[i][j] = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(grid[i][0] == 1) dfs(grid, i, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(grid[i][M-1] == 1) dfs(grid, i, M-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(grid[0][j] == 1) dfs(grid, 0, j);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(grid[N-1][j] == 1) dfs(grid, N-1, j);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for (int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(grid[i][j] == 1) grid[i][j] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                else if(grid[i][j] == 2) grid[i][j] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for (int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                System.out.print(grid[i][j] + &quot; &quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static void dfs(int[][] grid, int x, int y){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        grid[x][y] = 2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; 4; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int next_x = x + dir[i][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int next_y = y + dir[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(next_x &gt;= 0 &amp;&amp; next_x &lt; grid.length &amp;&amp; next_y &gt;= 0 &amp;&amp; next_y &lt; grid[0].length &amp;&amp; grid[next_x][next_y] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                dfs(grid, next_x, next_y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="103-水流问题">103. 水流问题<a href="#103-水流问题" class="hash-link" aria-label="Direct link to 103. 水流问题" title="Direct link to 103. 水流问题">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1175" target="_blank" rel="noopener noreferrer">卡码网题目链接（ACM 模式）</a></p>
<p>题目描述：</p>
<p>现有一个 N × M 的矩阵，每个单元格包含一个数值，这个数值代表该位置的相对高度。矩阵的左边界和上边界被认为是第一组边界，而矩阵的右边界和下边界被视为第二组边界。</p>
<p>矩阵模拟了一个地形，当雨水落在上面时，水会根据地形的倾斜向低处流动，但只能从较高或等高的地点流向较低或等高并且相邻（上下左右方向）的地点。我们的目标是确定那些单元格，从这些单元格出发的水可以达到第一组边界和第二组边界。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DFS</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.Scanner;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] grid = new int[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for (int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                grid[i][j] = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[][] visited_second = new boolean[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[][] visited_first = new boolean[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dfs(grid, i, 0, visited_first, Integer.MIN_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dfs(grid, i, M-1, visited_second, Integer.MIN_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dfs(grid, N-1, j, visited_second, Integer.MIN_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dfs(grid, 0, j, visited_first, Integer.MIN_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for (int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(visited_second[i][j] &amp;&amp; visited_first[i][j]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    System.out.println(i + &quot; &quot; + j);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static void dfs(int[][] grid, int x, int y, boolean[][] visited, int preH){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(x &lt; 0 || x &gt;= grid.length || y &lt; 0 || y &gt;= grid[0].length || visited[x][y]) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(grid[x][y] &lt; preH) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        visited[x][y] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; 4; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int next_x = x + dir[i][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int next_y = y + dir[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dfs(grid, next_x, next_y, visited, grid[x][y]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="104建造最大岛屿">104.建 造最大岛屿<a href="#104建造最大岛屿" class="hash-link" aria-label="Direct link to 104.建造最大岛屿" title="Direct link to 104.建造最大岛屿">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1176" target="_blank" rel="noopener noreferrer">卡码网题目链接（ACM 模式）</a></p>
<p>题目描述：</p>
<p>给定一个由 1（陆地）和 0（水）组成的矩阵，你最多可以将矩阵中的一格水变为一块陆地，在执行了此操作之后，矩阵中最大的岛屿面积是多少。</p>
<p>岛屿面积的计算方式为组成岛屿的陆地的总数。岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。你可以假设矩阵外均被水包围。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DFS</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.Scanner;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int cnt = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] grid = new int[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for (int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                grid[i][j] = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for (int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for (int j = 0; j &lt; M; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(grid[i][j] == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    boolean[][] visited = new boolean[N][M];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    grid[i][j] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dfs(grid, i, j, visited);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(cnt &gt; res) res = cnt;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    cnt = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    grid[i][j] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(res == 0 ? N*M : res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static void dfs(int[][] grid, int x, int y, boolean[][] visited){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(grid[x][y] == 0 || visited[x][y]) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        visited[x][y] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        cnt++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; 4; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int next_x = x + dir[i][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int next_y = y + dir[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(next_x &lt; 0 || next_x &gt;= grid.length || next_y &lt; 0 || next_y &gt;= grid[0].length) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dfs(grid, next_x, next_y, visited);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="110-字符串接龙">110. 字符串接龙<a href="#110-字符串接龙" class="hash-link" aria-label="Direct link to 110. 字符串接龙" title="Direct link to 110. 字符串接龙">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1183" target="_blank" rel="noopener noreferrer">卡码网题目链接（ACM 模式）</a></p>
<p>题目描述</p>
<p>字典 strList 中从字符串 beginStr 和 endStr 的转换序列是一个按下述规格形成的序列：</p>
<ol>
<li>序列中第一个字符串是 beginStr。</li>
<li>序列中最后一个字符串是 endStr。</li>
<li>每次转换只能改变一个字符。</li>
<li>转换过程中的中间字符串必须是字典 strList 中的字符串。</li>
</ol>
<p>给你两个字符串 beginStr 和 endStr 和一个字典 strList，找到从 beginStr 到 endStr 的最短转换序列中的字符串数目。如果不存在这样的转换序列，返回 0。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DFS</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int n = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.nextLine();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        String beginStr = scanner.next();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        String endStr = scanner.next();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.nextLine();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;String&gt; Str = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Str.add(beginStr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Str.add(endStr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            Str.add(scanner.nextLine());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int cnt = dfs(Str, beginStr, endStr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(cnt);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static int dfs(List&lt;String&gt; Str, String beginStr, String endStr){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int len = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Set&lt;String&gt; set = new HashSet&lt;&gt;(Str);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        visited.add(beginStr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue.add(beginStr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue.add(null);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!queue.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            String curStr = queue.remove();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(curStr == null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(!queue.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    len++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    queue.add(null);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            char[] ss = curStr.toCharArray();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int i = 0; i &lt; ss.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                char old = ss[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                for(char j = &#x27;a&#x27;; j &lt;= &#x27;z&#x27;; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    ss[i] = j;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    String newStr = new String(ss);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(set.contains(newStr) &amp;&amp; !visited.contains(newStr)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        queue.add(newStr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        visited.add(newStr);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        if(newStr.equals(endStr)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                            return len+1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                ss[i] = old;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="105有向图的完全可达性">105.有向图的完全可达性<a href="#105有向图的完全可达性" class="hash-link" aria-label="Direct link to 105.有向图的完全可达性" title="Direct link to 105.有向图的完全可达性">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1177" target="_blank" rel="noopener noreferrer">卡码网题目链接（ACM 模式）</a></p>
<p>【题目描述】</p>
<p>给定一个有向图，包含 N 个节点，节点编号分别为 1，2，...，N。现从 1 号节点开始，如果可以从 1 号节点的边可以到达任何节点，则输出 1，否则输出 -1。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;List&lt;Integer&gt;&gt; dir = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int points = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int edges = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; points; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dir.add(new ArrayList&lt;&gt;());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; edges; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int a = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int b = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dir.get(a-1).add(b-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] visited = new boolean[points];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // dfs(dir, visited, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        bfs(dir, visited, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; visited.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(!visited[i]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                System.out.println(-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static void dfs(List&lt;List&lt;Integer&gt;&gt; dir, boolean[] visited, int start){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(visited[start]) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        visited[start] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i : dir.get(start)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dfs(dir, visited, i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static void bfs(List&lt;List&lt;Integer&gt;&gt; dir, boolean[] visited, int start){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;Integer&gt; dequeue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dequeue.offer(start);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        visited[start] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!dequeue.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur = dequeue.pollLast();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int i : dir.get(cur)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(!visited[i]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dequeue.offer(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    visited[i] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="106-岛屿的周长">106. 岛屿的周长<a href="#106-岛屿的周长" class="hash-link" aria-label="Direct link to 106. 岛屿的周长" title="Direct link to 106. 岛屿的周长">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1178" target="_blank" rel="noopener noreferrer">卡码网题目链接（ACM 模式）</a></p>
<p>题目描述</p>
<p>给定一个由 1（陆地）和 0（水）组成的矩阵，岛屿是被水包围，并且通过水平方向或垂直方向上相邻的陆地连接而成的。</p>
<p>你可以假设矩阵外均被水包围。在矩阵中恰好拥有一个岛屿，假设组成岛屿的陆地边长都为 1，请计算岛屿的周长。岛屿内部没有水域。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] grid = new int[M][N];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; N; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                grid[i][j] = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] dir = {{-1,0},{0,1},{1,0},{0,-1}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int count = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; N; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                for(int k = 0; k &lt; 4; k++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(grid[i][j] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        int next_x = i + dir[k][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        int next_y = j + dir[k][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        if(next_x &lt; 0 || next_x &gt;= M || next_y &lt; 0 || next_y &gt;= N || grid[next_x][next_y] == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                            count++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(count);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="并查集理论基础">并查集理论基础<a href="#并查集理论基础" class="hash-link" aria-label="Direct link to 并查集理论基础" title="Direct link to 并查集理论基础">​</a></h2>
<p>并查集常用来解决连通性问题，也就是当我们需要判断两个元素是否在同一个集合里的时候，我们就要想到用并查集。</p>
<p>并查集主要有两个功能：</p>
<ul>
<li>将两个元素添加到一个集合中</li>
<li>判断两个元素在不在同一个集合</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="原理">原理<a href="#原理" class="hash-link" aria-label="Direct link to 原理" title="Direct link to 原理">​</a></h3>
<ul>
<li>
<p>如何将两个元素添加到同一个集合中？</p>
<p>可以用有向连通图,只需要用一个一维数组来表示，即：father[A] = B，father[B] = C，此时 A 和 B 有同一个根 C</p>
</li>
</ul>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="路径压缩">路径压缩<a href="#路径压缩" class="hash-link" aria-label="Direct link to 路径压缩" title="Direct link to 路径压缩">​</a></h4>
<p>在实现 find 函数的过程中，通过递归的方式，不断获取 father 数组下标对应的数值，最终找到这个集合的根。</p>
<p>搜索过程像是一个多叉树中从叶子到根节点的过程，如图：</p>
<p><img decoding="async" loading="lazy" alt="20230602102619" src="/assets/images/20230602102619-0d5efd0714e3a6a5e1fa629884b128b9.png" width="1058" height="740" class="img_ev3q"></p>
<p>如果这棵多叉树高度很深的话，每次 find 函数 去寻找根的过程就要递归很多次。</p>
<p>我们的目的只需要知道这些节点在同一个根下就可以，所以对这棵多叉树的构造只需要这样就可以了，如图：</p>
<p><img decoding="async" loading="lazy" alt="20230602103040" src="/assets/images/20230602103040-c5e676a867f1e6b6dee74841c5c08acb.png" width="1014" height="446" class="img_ev3q"></p>
<p>除了根节点其他所有节点都挂载根节点下，这样我们在寻根的时候就很快，只需要一步，如果我们想达到这样的效果，就需要 <strong>路径压缩</strong>，将非根节点的所有节点直接指向根节点,只需要在递归的过程中，让 father[u] 接住 递归函数 find(father[u]) 的返回结果。</p>
<h5 class="anchor anchorWithStickyNavbar_LWe7" id="代码模板">代码模板<a href="#代码模板" class="hash-link" aria-label="Direct link to 代码模板" title="Direct link to 代码模板">​</a></h5>
<div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> n </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1005</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// n  根据题目中节点数量而定，一般比节点数量大一点就好</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">vector</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> father </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token generic-function function" style="color:hsl(221, 87%, 60%)">vector</span><span class="token generic-function generic class-name operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token generic-function generic class-name keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token generic-function generic class-name operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">n</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// C++里的一种数组结构</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 并查集初始化</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token keyword" style="color:hsl(301, 63%, 40%)">void</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">init</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> i </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> i </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token plain"> n</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">++</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 并查集里寻根的过程</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> father</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">?</span><span class="token plain"> u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">:</span><span class="token plain"> father</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">father</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 路径压缩</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 判断 u 和 v是否找到同一个根</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token keyword" style="color:hsl(301, 63%, 40%)">bool</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">isSame</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    v </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 将v合并到u中</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token keyword" style="color:hsl(301, 63%, 40%)">void</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">join</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 寻找u的根</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    v </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 寻找v的根</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 如果发现根相同，则说明在一个集合，不用两个节点相连直接返回</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    father</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="按秩rank合并">按秩（rank）合并<a href="#按秩rank合并" class="hash-link" aria-label="Direct link to 按秩（rank）合并" title="Direct link to 按秩（rank）合并">​</a></h4>
<p>rank 表示树的高度，即树中结点层次的最大值。</p>
<p>例如两个集合（多叉树）需要合并，如图所示：</p>
<p><img decoding="async" loading="lazy" alt="20250227_165915_203_copy" src="/assets/images/20250227_165915_203_copy-da1ce0eb88d4713c4d5ceb5328ce7602.png" width="1088" height="628" class="img_ev3q"></p>
<p>树 1 rank 为 2，树 2 rank 为 3，在 join 函数中，一定是 rank 小的树合入到 rank 大的树，这样可以保证最后合成的树 rank 最小，降低在树上查询的路径长度。</p>
<p><img decoding="async" loading="lazy" alt="image-20250227170055899" src="/assets/images/image-20250227170055899-a6f44508b1ea6e3b7ddfd6caa9fd6578.png" width="344" height="235" class="img_ev3q"></p>
<p>按秩合并的代码如下：</p>
<div class="language-cpp codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-cpp codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> n </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1005</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// n根据题目中节点数量而定，一般比节点数量大一点就好</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">vector</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> father </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token generic-function function" style="color:hsl(221, 87%, 60%)">vector</span><span class="token generic-function generic class-name operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token generic-function generic class-name keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token generic-function generic class-name operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">n</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// C++里的一种数组结构</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">vector</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> rank </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token generic-function function" style="color:hsl(221, 87%, 60%)">vector</span><span class="token generic-function generic class-name operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token generic-function generic class-name keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token generic-function generic class-name operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">n</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 初始每棵树的高度都为1</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 并查集初始化</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token keyword" style="color:hsl(301, 63%, 40%)">void</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">init</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> i </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> i </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token plain"> n</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">++</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        rank</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 也可以不写</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 并查集里寻根的过程</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> father</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">?</span><span class="token plain"> u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">:</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">father</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 注意这里不做路径压缩</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 判断 u 和 v是否找到同一个根</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token keyword" style="color:hsl(301, 63%, 40%)">bool</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">isSame</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    v </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 将v-&gt;u 这条边加入并查集</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token keyword" style="color:hsl(301, 63%, 40%)">void</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">join</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">int</span><span class="token plain"> v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 寻找u的根</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    v </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">find</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 寻找v的根</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">rank</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;=</span><span class="token plain"> rank</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> father</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// rank小的树合入到rank大的树</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">else</span><span class="token plain"> father</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">rank</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">u</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> rank</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&amp;&amp;</span><span class="token plain"> u </span><span class="token operator" style="color:hsl(221, 87%, 60%)">!=</span><span class="token plain"> v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> rank</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">v</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token operator" style="color:hsl(221, 87%, 60%)">++</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">;</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)">// 如果两棵树高度相同，则v的高度+1，因为上面 if (rank[u] &lt;= rank[v]) father[u] = v; 注意是 &lt;=</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain"></span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p>按秩合并的思路并没有将树形结构尽可能的扁平化，所以在整理效率上是没有路径压缩高的，<strong>直接使用路径压缩的并查集模板就好</strong>。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="复杂度分析">复杂度分析<a href="#复杂度分析" class="hash-link" aria-label="Direct link to 复杂度分析" title="Direct link to 复杂度分析">​</a></h3>
<p>对路径压缩版并查集来做分析。</p>
<ul>
<li>
<p>空间复杂度： O(n) ，申请一个 father 数组。</p>
</li>
<li>
<p>时间复杂度：如果想精确表达出来需要繁琐的数学证明，这里做一个简单的分析思路。</p>
<p>路径压缩后的并查集时间复杂度在 O(logn)与 O(1)之间，且随着查询或者合并操作的增加，时间复杂度会越来越趋于 O(1)，在第一次查询的时候，相当于是 n 叉树上从叶子节点到根节点的查询过程，时间复杂度是 logn，但路径压缩后，后面的查询操作都是 O(1)，而 join 函数 和 isSame 函数 里涉及的查询操作也是一样的过程。</p>
</li>
</ul>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目">题目<a href="#题目" class="hash-link" aria-label="Direct link to 题目" title="Direct link to 题目">​</a></h3>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="107-寻找存在的路径">107. 寻找存在的路径<a href="#107-寻找存在的路径" class="hash-link" aria-label="Direct link to 107. 寻找存在的路径" title="Direct link to 107. 寻找存在的路径">​</a></h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1179" target="_blank" rel="noopener noreferrer">卡码网题目链接（ACM 模式）</a></p>
<p>题目描述</p>
<p>给定一个包含 n 个节点的无向图中，节点编号从 1 到 n （含 1 和 n ）。</p>
<p>你的任务是判断是否有一条从节点 source 出发到节点 destination 的路径存在。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int points = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int edges = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Disjoint disjoint = new Disjoint(points+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; edges; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            disjoint.join(scanner.nextInt(), scanner.nextInt());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(disjoint.isSame(scanner.nextInt(), scanner.nextInt())){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Disjoint{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] father;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Disjoint(int n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father = new int[n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            father[i] = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int find(int x){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return father[x] == x ? x : find(father[x]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void join(int x, int y){ // x -&gt; y</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int fx = find(x);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int fy = find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father[fx] = fy;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isSame(int x, int y){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return find(x) == find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="108-冗余连接">108. 冗余连接<a href="#108-冗余连接" class="hash-link" aria-label="Direct link to 108. 冗余连接" title="Direct link to 108. 冗余连接">​</a></h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1181" target="_blank" rel="noopener noreferrer">卡码网题目链接（ACM 模式）</a></p>
<p>题目描述</p>
<p>有一个图，它是一棵树，他是拥有 n 个节点（节点编号 1 到 n）和 n - 1 条边的连通无环无向图（其实就是一个线形图），如图：</p>
<p><img decoding="async" loading="lazy" alt="20240905163122" src="/assets/images/20240905163122-42bc47c48094b6392396a3a429372bd8.png" width="604" height="632" class="img_ev3q"></p>
<p>现在在这棵树上的基础上，添加一条边（依然是 n 个节点，但有 n 条边），使这个图变成了有环图，如图</p>
<p><img decoding="async" loading="lazy" alt="20240905164721" src="/assets/images/20240905164721-617084d908297604d575aa70b46e7222.png" width="732" height="642" class="img_ev3q"></p>
<p>先请你找出冗余边，删除后，使该图可以重新变成一棵树。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int n = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Disjoint disjoint = new Disjoint(n+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] last = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            last[0] = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            last[1] = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(disjoint.isSame(last[0], last[1])){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res[0] = last[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res[1] = last[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                disjoint.join(last[0], last[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(res[0] + &quot; &quot; + res[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Disjoint{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] father;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Disjoint(int n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father = new int[n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            father[i] = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int find(int x){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return father[x] == x ? x : find(father[x]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void join(int x, int y){ // x -&gt; y</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int fx = find(x);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int fy = find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father[fx] = fy;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isSame(int x, int y){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return find(x) == find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="109-冗余连接-ii">109. 冗余连接 II<a href="#109-冗余连接-ii" class="hash-link" aria-label="Direct link to 109. 冗余连接 II" title="Direct link to 109. 冗余连接 II">​</a></h4>
<p><a href="https://kamacoder.com/problempage.php?pid=1182" target="_blank" rel="noopener noreferrer">卡码网题目链接（ACM 模式）</a></p>
<p>题目描述</p>
<p>有一种有向树,该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。有向树拥有 n 个节点和 n - 1 条边。如图：</p>
<p><img decoding="async" loading="lazy" alt="20240827152106" src="/assets/images/20240827152106-8ab95088d60fe7ffe132270b133df3a3.png" width="328" height="340" class="img_ev3q"></p>
<p>现在有一个有向图，有向图是在有向树中的两个没有直接链接的节点中间添加一条有向边。如图：</p>
<p><img decoding="async" loading="lazy" alt="20240827152134" src="/assets/images/20240827152134-549b56e667c59903bf872921304632d7.png" width="372" height="378" class="img_ev3q"></p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Disjoint{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] father;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Disjoint(int n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father = new int[n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            father[i] = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int find(int x){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return father[x] == x ? x : find(father[x]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void join(int x, int y){ // x -&gt; y</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int fx = find(x);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int fy = find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father[fx] = fy;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isSame(int x, int y){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return find(x) == find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Edge{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int start;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int end;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Edge(int start, int end){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.start = start;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.end = end;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Node{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int in;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int out;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int n = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Disjoint disjoint = new Disjoint(n+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Edge&gt; edges = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Node[] nodes = new Node[n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            nodes[i] = new Node();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Integer doubleIn = null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            edges.add(new Edge(s, t));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            nodes[t].in++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(nodes[t].in &gt;= 2) doubleIn = t;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Edge res = null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(doubleIn != null){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            List&lt;Edge&gt; doubleInEdges = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(Edge edge : edges){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(edge.end == doubleIn){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    doubleInEdges.add(edge);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(doubleInEdges.size() == 2) break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            Edge edge = doubleInEdges.get(1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(isTreeWithExclude(edges, edge, nodes)) res = edge;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else res = doubleInEdges.get(0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res = RemoveEdge(edges, nodes);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(res.start + &quot; &quot; + res.end);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static boolean isTreeWithExclude(List&lt;Edge&gt; edges, Edge excludedEdge, Node[] nodes){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Disjoint disjoint = new Disjoint(nodes.length);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(Edge edge : edges){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(edge == excludedEdge) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(disjoint.isSame(edge.start, edge.end)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            disjoint.join(edge.start, edge.end);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static Edge RemoveEdge(List&lt;Edge&gt; edges, Node[] nodes){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Disjoint disjoint = new Disjoint(nodes.length);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(Edge edge : edges){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(disjoint.isSame(edge.start, edge.end)) return edge;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            disjoint.join(edge.start, edge.end);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="最小生成树">最小生成树<a href="#最小生成树" class="hash-link" aria-label="Direct link to 最小生成树" title="Direct link to 最小生成树">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="prim-算法">prim 算法<a href="#prim-算法" class="hash-link" aria-label="Direct link to prim 算法" title="Direct link to prim 算法">​</a></h3>
<p>最小生成树是所有节点的最小连  通子图，即：以最小的成本（边的权值）将图中所有节点链接到一起。</p>
<p>prim 算法是从节点的角度采用贪心的策略每次寻找距离最小生成树最近的节点并加入到最小生成树中。</p>
<p>prim 算法核心就是三步：</p>
<ol>
<li>选距离生成树最近节点</li>
<li>最近节点加入生成树</li>
<li>更新非生成树节点到生成树的距离（即更新 minDist 数组）</li>
</ol>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="kruskal-算法">kruskal 算法<a href="#kruskal-算法" class="hash-link" aria-label="Direct link to kruskal 算法" title="Direct link to kruskal 算法">​</a></h3>
<p>prim 算法是<strong>维护节点</strong>的集合，而 Kruskal 是<strong>维护边</strong>的集合</p>
<p>kruscal 的思路：</p>
<ul>
<li>边的权值排序，因为要优先选最小的边加入到生成树里</li>
<li>遍历排序后的边
<ul>
<li>如果边首尾的两个节点在同一个集合，说明如果连上这条边图中会出现环</li>
<li>如果边首尾的两个节点不在同一个集合，加入到最小生成树，并把两个节点加入同一个集合</li>
</ul>
</li>
</ul>
<p>在节点数量固定的情况下，图中的边越少，Kruskal 需要遍历的边也就越少。而 prim 算法是对节点进行操作的，节点数量越少，prim 算法效率就越优。</p>
<p>所以在 稀疏图中，用 Kruskal 更优。 在稠密图中，用 prim 算法更优。</p>
<blockquote>
<p>边数量较少为稀疏图，接近或等于完全图（所有节点皆相连）为稠密图</p>
</blockquote>
<p>Prim 算法 时间复杂度为 O(n^2)，其中 n 为节点数量，它的运行效率和图中边树无关，适用稠密图。Kruskal 算法 时间复杂度 为 nlogn，其中 n 为边的数量，适用稀疏图。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-1">题目<a href="#题目-1" class="hash-link" aria-label="Direct link to 题目" title="Direct link to 题目">​</a></h3>
<p><a href="https://kamacoder.com/problempage.php?pid=1053" target="_blank" rel="noopener noreferrer">卡码网：53. 寻宝</a></p>
<p>题目描述：</p>
<p>在世界的某个区域，有一些分散的神秘岛屿，每个岛屿上都有一种珍稀的资源或者宝藏。国王打算在这些岛屿上建公路，方便运输。</p>
<p>不同岛屿之间，路途距离不同，国王希望你可以规划建公路的方案，如何可以以最短的总公路距离将所有岛屿联通起来。</p>
<p>给定一张地图，其中包括了所有的岛屿，以及它们之间的距离。以最小化公路建设长度，确保可以链接到所有岛屿。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// prim算法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int E = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] edges = new int[N+1][N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            Arrays.fill(edges[i], 10001); // 将所有边权初始化为10001，表示不存在的边</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; E; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int w = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            edges[s][t] = w;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            edges[t][s] = w;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(minDist, 10001);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] isIntree = new boolean[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // prim算法-主循环</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur = -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int min = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= N; j++){ // 寻找未加入树的节点中距离最近的节点</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(!isIntree[j] &amp;&amp; minDist[j] &lt; min){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    cur = j;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    min = minDist[j];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            isIntree[cur] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= N; j++){ // 更新各个节点距离生成树的最小距离</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(!isIntree[j] &amp;&amp; edges[cur][j] &lt; minDist[j]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    minDist[j] = edges[cur][j];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 2; i &lt;= N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res += minDist[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// kruskal算法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Edge{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int start;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int end;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int weight;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Edge(int start, int end, int weight){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.start = start;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.end = end;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.weight = weight;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class DisjointSet{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] father; // 记录各个节点的父节点</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public DisjointSet(int n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father = new int[n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            father[i] = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int find(int x){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return x == father[x]? x : (father[x] = find(father[x]));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void join(int x, int y){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father[find(x)] = find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isSameSet(int x, int y){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return find(x) == find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int E = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        DisjointSet disjointSet = new DisjointSet(N+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Edge&gt; edges = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; E; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int start = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int end = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int weight = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            edges.add(new Edge(start, end, weight));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        edges.sort(Comparator.comparingInt(a -&gt; a.weight)); // 按权重排序</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(Edge edge : edges){ //kruskal算法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(!disjointSet.isSameSet(edge.start, edge.end)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res += edge.weight;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                disjointSet.join(edge.start, edge.end);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        System.out.println(res);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="拓扑排序精讲">拓扑排序精讲<a href="#拓扑排序精讲" class="hash-link" aria-label="Direct link to 拓扑排序精讲" title="Direct link to 拓扑排序精讲">​</a></h2>
<p>给出一个 有向图，把这个有向图转成线性的排序 就叫拓扑排序。拓扑排序也要检测这个有向图 是否有环，即存在循环依赖的情况，因为这种情况是不能做线性排序的。</p>
<p>其实只要能在把 有向无环图 进行线性排序 的算法 都可以叫做 拓扑排序。</p>
<p>实现拓扑排序的算法有两种：<strong>卡恩算法</strong>（BFS）和 DFS</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-2">题目<a href="#题目-2" class="hash-link" aria-label="Direct link to 题目" title="Direct link to 题目">​</a></h3>
<p><a href="https://kamacoder.com/problempage.php?pid=1191" target="_blank" rel="noopener noreferrer">卡码网：117. 软件构建</a></p>
<p>题目描述：</p>
<p>某个大型软件项目的构建系统拥有 N 个文件，文件编号从 0 到 N - 1，在这些文件中，某些文件依赖于其他文件的内容，这意味着如果文件 A 依赖于文件 B，则必须在处理文件 A 之前处理文件 B （0 &lt;= A, B &lt;= N - 1）。请编写一个算法，用于确定文件处理的顺序。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int E = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;List&lt;Integer&gt;&gt; graph = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] inDegree = new int[N]; //记录每个节点的入度</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.add(new ArrayList&lt;&gt;());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; E; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int start = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int end = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            inDegree[end]++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.get(start).add(end);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(inDegree[i] == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                deque.offer(i);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            res.add(cur);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int next : graph.get(cur)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                inDegree[next]--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(inDegree[next] == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.offer(next);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(res.size() != N){ //有环</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int i = 0; i &lt; N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(i == N - 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    System.out.print(res.get(i));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                else System.out.print(res.get(i) + &quot; &quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="dijkstra">dijkstra<a href="#dijkstra" class="hash-link" aria-label="Direct link to dijkstra" title="Direct link to dijkstra">​</a></h2>
<p>dijkstra 算法：在有权图（权值非负数）中求从起点到其他节点的最短路径算法。</p>
<p>对于负权值的出现，针对某一个场景不断去修改 dijkstra 的代码，<strong>但最终会发现只  是 拆了东墙补西墙</strong>，对 dijkstra 的补充逻辑只能满足某特定场景最短路求解。</p>
<p>dijkstra 算法的注意点：</p>
<ul>
<li>dijkstra 算法可以同时求起点到所有节点的最短路径</li>
<li>权值不能为负数</li>
</ul>
<p>dijkstra 算法的步骤：</p>
<ol>
<li>选择离源点近且未被访问过的节点</li>
<li>将该节点标记为已访问</li>
<li>更新未访问节点到源点的距离（即更新 minDist 数组）</li>
</ol>
<p>prim 和 dijkstra 很类似，但是 dijkstra 算法的实现更加复杂。<strong>prim 是求非访问节点到最小生成树的最小距离，而 dijkstra 是求非访问节点到源点的最小距离</strong>。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-3">题目<a href="#题目-3" class="hash-link" aria-label="Direct link to 题目" title="Direct link to 题目">​</a></h3>
<p><a href="https://kamacoder.com/problempage.php?pid=1047" target="_blank" rel="noopener noreferrer">卡码网：47. 参加科学大会</a></p>
<p>【题目描述】</p>
<p>小明是一位科学家，他需要参加一场重要的国际科学大会，以展示自己的最新研究成果。</p>
<p>小明的起点是第一个车站，终点是最后一个车站。然而，途中的各个车站之间的道路状况、交通拥堵程度以及可能的自然因素（如天气变化）等不同，这些因素都会影响每条路径的通行时间。</p>
<p>小明希望能选择一条花费时间最少的路线，以确保他能够尽快到达目的地。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//朴素版</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] graph = new int[N+1][N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= N; i++) Arrays.fill(graph[i], Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int val = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph[s][t] = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int start = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int end = N;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(minDist, Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        minDist[start] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] visited = new boolean[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int min = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur = -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= N; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(!visited[j] &amp;&amp; minDist[j] &lt; min){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    min = minDist[j];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    cur = j;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(cur == -1) break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            visited[cur] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 1; j &lt;= N; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(!visited[j] &amp;&amp; graph[cur][j] != Integer.MAX_VALUE &amp;&amp; graph[cur][j] + minDist[cur] &lt; minDist[j]){ //非访问节点是因为路径为正，所以可以直接排除</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    minDist[j] = graph[cur][j] + minDist[cur];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(minDist[end] == Integer.MAX_VALUE) System.out.println(-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else System.out.println(minDist[end]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// 堆优化版，自动排序（PriorityQueue）</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Edge{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Edge(int to, int val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.to = to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.val = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Pair&lt;U, V&gt;{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public final U first;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public final V second;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Pair(U first, V second){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.first = first;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.second = second;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class MyComparator implements Comparator&lt;Pair&lt;Integer, Integer&gt;&gt;{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int compare(Pair&lt;Integer, Integer&gt; a, Pair&lt;Integer, Integer&gt; b){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Integer.compare(a.second, b.second);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;List&lt;Edge&gt;&gt; graph = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; N+1; i++) graph.add(new ArrayList&lt;&gt;());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int val = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.get(s).add(new Edge(t, val));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int start = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int end = N;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(minDist, Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        minDist[start] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] visited = new boolean[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        PriorityQueue&lt;Pair&lt;Integer, Integer&gt;&gt; pq = new PriorityQueue&lt;&gt;(new MyComparator());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        pq.offer(new Pair&lt;&gt;(start, 0));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!pq.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            Pair&lt;Integer, Integer&gt; curr = pq.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(visited[curr.first]) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            visited[curr.first] = true; // 确定了该点w</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(Edge e : graph.get(curr.first)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(!visited[e.to] &amp;&amp; minDist[e.to] &gt; minDist[curr.first] + e.val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    minDist[e.to] = minDist[curr.first] + e.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    pq.offer(new Pair&lt;&gt;(e.to, minDist[e.to]));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(minDist[end] == Integer.MAX_VALUE) System.out.println(-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else System.out.println(minDist[end]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="bellman_ford-算法">Bellman_ford 算法<a href="#bellman_ford-算法" class="hash-link" aria-label="Direct link to Bellman_ford 算法" title="Direct link to Bellman_ford 算法">​</a></h2>
<p>在 求单源最短路的方法中，使用 dijkstra 的话，则要求图中边的权值都为正数。</p>
<p>带<strong>负权值</strong>的单源最短路问题，此时就轮到 Bellman_ford 登场了</p>
<p>Bellman_ford 算法的核心思想是<strong>对所有边进行松弛 n-1 次操作</strong>（n 为节点数量），从而求得目标最短路。</p>
<p><strong>Bellman_ford 队列优化算法</strong></p>
<p>只需要对 上一次松弛的时候更新过的节点作为出发节点所连接的边 进行松弛就够了。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-4">题目<a href="#题目-4" class="hash-link" aria-label="Direct link to 题目" title="Direct link to 题目">​</a></h3>
<p><a href="https://kamacoder.com/problempage.php?pid=1152" target="_blank" rel="noopener noreferrer">卡码网：94. 城市间货物运输 I</a></p>
<p>题目描述</p>
<p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p>
<p>网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。</p>
<p>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p>
<p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。</p>
<p>如果最低运输成本是一个负数，它表示在遵循最优路径的情况下，运输过程中反而能够实现盈利。</p>
<p>城市 1 到城市 n 之间可能会出现没有路径的情况，同时保证道路网络中不存在任何负权回路。</p>
<blockquote>
<p>负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无  限地增加总收益。</p>
</blockquote>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Edge{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Edge(int from, int to, int val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.from = from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.to = to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.val = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Edge&gt; graph = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int val = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.add(new Edge(s, t, val));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(minDist, Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        minDist[1] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt; N; i++){ // 松弛(N-1)次</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(Edge edge : graph){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(minDist[edge.from] != Integer.MAX_VALUE)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    minDist[edge.to] = Math.min(minDist[edge.to], minDist[edge.from] + edge.val);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(minDist[N] == Integer.MAX_VALUE)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(&quot;unconnected&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(minDist[N]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//Bellman_ford 队列优化算法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Edge{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Edge(int from, int to, int val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.from = from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.to = to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.val = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;List&lt;Edge&gt;&gt; graph = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt;= N; i++) graph.add(new ArrayList&lt;&gt;());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int val = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.get(s).add(new Edge(s, t, val));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(minDist, Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        minDist[1] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] isInQueue = new boolean[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        isInQueue[1] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        // SPFA算法核心：只对上一次松弛的时候更新过的节点关联的边进行松弛操作</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            isInQueue[cur] = false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(Edge edge : graph.get(cur)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(minDist[edge.to] &gt; (minDist[cur] + edge.val)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    minDist[edge.to] = minDist[cur] + edge.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(!isInQueue[edge.to]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        deque.offer(edge.to);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        isInQueue[edge.to] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(minDist[N] == Integer.MAX_VALUE)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(&quot;unconnected&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(minDist[N]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="bellman_ford-之判断负权回路">Bellman_ford 之判断负权回路<a href="#bellman_ford-之判断负权回路" class="hash-link" aria-label="Direct link to Bellman_ford 之判断负权回路" title="Direct link to Bellman_ford 之判断负权回路">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1153" target="_blank" rel="noopener noreferrer">卡码网：95. 城市间货物运输 II</a></p>
<p>【题目描述】</p>
<p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p>
<p>网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。权值为正表示扣除了政府补贴后运输货物仍需支付的费用；</p>
<p>权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p>
<p>然而，在评估从城市 1 到城市 n 的所有可能路径中综合政府补贴后的最低运输成本时，存在一种情况：<strong>图中可能出现负权回路</strong>。</p>
<p>负权回路是指一系列道路的总权值为负，这样的回路使得通过反复经过回路中的道路，理论上可以无限地减少总成本或无限地增加总收益。</p>
<p>为了避免货物运输商采用负权回路这种情况无限的赚取政府补贴，算法还需检测这种特殊情况。</p>
<p>请找出从城市 1 到城市 n 的所有可能路径中，综合政府补贴后的最低运输成本。同时能够检测并适当处理负权回路的存在。</p>
<p>城市 1 到城市 n 之间可能会出现没有路径的情况</p>
<p>解答</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// Bellman-Ford方法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Edge{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Edge(int from, int to, int val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.from = from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.to = to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.val = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Edge&gt; graph = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int val = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.add(new Edge(s, t, val));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(minDist, Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        minDist[1] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean flag = false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= N; i++){ //增加一次松弛操作</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(Edge e : graph){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(i &lt; N){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(minDist[e.from] != Integer.MAX_VALUE &amp;&amp; minDist[e.from] + e.val &lt; minDist[e.to]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        minDist[e.to] = minDist[e.from] + e.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                else{ //如果加一次松弛操作后，minDist[N]变化，说明有环</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(minDist[e.from] != Integer.MAX_VALUE &amp;&amp; minDist[e.from] + e.val &lt; minDist[e.to]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        flag = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(flag) System.out.println(&quot;circle&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else if(minDist[N] == Integer.MAX_VALUE)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(&quot;unconnected&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(minDist[N]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// SPFA方法求解</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Edge{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Edge(int from, int to, int val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.from = from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.to = to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.val = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;List&lt;Edge&gt;&gt; graph = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt;= N; i++) graph.add(new ArrayList&lt;&gt;());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int val = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.get(s).add(new Edge(s, t, val));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(minDist, Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        minDist[1] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] isInQueue = new boolean[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        isInQueue[1] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean flag = false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] cnt = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        cnt[1]++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            isInQueue[cur] = false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(Edge edge : graph.get(cur)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(minDist[edge.to] &gt; (minDist[cur] + edge.val)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    minDist[edge.to] = minDist[cur] + edge.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(!isInQueue[edge.to]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        deque.offer(edge.to);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        isInQueue[edge.to] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        cnt[edge.to]++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        if(cnt[edge.to] == N){ // 正情况下，加入队列的节点数不会超过N，但当加入到队列的节点等于N时，说明找到了环</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                            flag = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                            while(!deque.isEmpty()) deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                            break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(flag) System.out.println(&quot;circle&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else if(minDist[N] == Integer.MAX_VALUE)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(&quot;unconnected&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(minDist[N]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="bellman_ford-之单源有限最短路">bellman_ford 之单源有限最短路<a href="#bellman_ford-之单源有限最短路" class="hash-link" aria-label="Direct link to bellman_ford 之单源有限最短路" title="Direct link to bellman_ford 之单源有限最短路">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1154" target="_blank" rel="noopener noreferrer">卡码网：96. 城市间货物运输 III</a></p>
<p>【题目描述】</p>
<p>某国为促进城市间经济交流，决定对货物运输提供补贴。共有 n 个编号为 1 到 n 的城市，通过道路网络连接，网络中的道路仅允许从某个城市单向通行到另一个城市，不能反向通行。</p>
<p>网络中的道路都有各自的运输成本和政府补贴，道路的权值计算方式为：运输成本 - 政府补贴。</p>
<p>权值为正表示扣除了政府补贴后运输货物仍需支付的费用；</p>
<p>权值为负则表示政府的补贴超过了支出的运输成本，实际表现为运输过程中还能赚取一定的收益。</p>
<p>请计算在最多经过 k 个城市的条件下，从城市 src 到城市 dst 的最低运输成本。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//bellman_ford一般方法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Edge{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Edge(int from, int to, int val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.from = from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.to = to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.val = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Edge&gt; graph = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int val = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.add(new Edge(s, t, val));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int start = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int end = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int constraint = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(minDist, Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        minDist[start] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist_copy = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; constraint+1; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            minDist_copy = Arrays.copyOf(minDist, N+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(Edge e : graph){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(minDist_copy[e.from] != Integer.MAX_VALUE &amp;&amp; minDist_copy[e.from] + e.val &lt; minDist[e.to]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    minDist[e.to] = minDist_copy[e.from] + e.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(minDist[end] == Integer.MAX_VALUE)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(&quot;unreachable&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(minDist[end]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// SPFA算法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Edge{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Edge(){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Edge(int to, int val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.to = to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.val = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public Edge(int from, int to, int val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.from = from;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.to = to;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.val = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;List&lt;Edge&gt;&gt; graph = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt;= N; i++) graph.add(new ArrayList&lt;&gt;());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int val = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.get(s).add(new Edge(t, val));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int start = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int end = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int constraint = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist = spfa(graph, N, start, constraint);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(minDist[end] == Integer.MAX_VALUE)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(&quot;unreachable&quot;);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            System.out.println(minDist[end]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int[] spfa(List&lt;List&lt;Edge&gt;&gt; graph, int N, int start, int constraint){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(minDist, Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        minDist[start] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        queue.offer(start);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] minDist_copy = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(constraint + 1 &gt; 0 &amp;&amp; !queue.isEmpty()){ // 限定松弛 constraint+1 次</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cursize = queue.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            while(cursize-- &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int cur = queue.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                minDist_copy = minDist.clone();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                for(Edge edge : graph.get(cur)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(minDist[edge.to] &gt; minDist_copy[cur] + edge.val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        minDist[edge.to] = minDist_copy[cur] + edge.val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        if(!queue.contains(edge.to) &amp;&amp; graph.get(edge.to).size() &gt; 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                            queue.offer(edge.to);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            constraint--;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return minDist;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="多源-bfs">多源 BFS<a href="#多源-bfs" class="hash-link" aria-label="Direct link to 多源 BFS" title="Direct link to 多源 BFS">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="1162-地图分析"><a href="https://leetcode.cn/problems/as-far-from-land-as-possible/" target="_blank" rel="noopener noreferrer">1162. 地图分析</a><a href="#1162-地图分析" class="hash-link" aria-label="Direct link to 1162-地图分析" title="Direct link to 1162-地图分析">​</a></h3>
<p>你现在手里有一份大小为 <code>n x n</code> 的 网格 <code>grid</code>，上面的每个 单元格 都用 <code>0</code> 和 <code>1</code> 标记好了。其中 <code>0</code> 代表海洋，<code>1</code> 代表陆地。</p>
<p>请你找出一个海洋单元格，这个海洋单元格到离它最近的陆地单元格的距离是最大的，并返回该距离。如果网格上只有陆地或者海洋，请返回 <code>-1</code>。</p>
<p>我们这里说的距离是「曼哈顿距离」（ Manhattan Distance）：<code>(x0, y0)</code> 和 <code>(x1, y1)</code> 这两个单元格之间的距离是 <code>|x0 - x1| + |y0 - y1|</code> 。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// 单源BFS 时间复杂度:O(n^4)，空间复杂度:O(n^2)，超时</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int[][] grid;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int n;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int[][] dir = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxDistance(int[][] _grid) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        grid = _grid;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        n = grid.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; n; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(grid[i][j] == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    res = Math.max(res, bfs(i, j));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int bfs(int i, int j){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;int[]&gt; deque = new ArrayDeque&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(new int[]{i,j});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int[] cur = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int x = cur[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int y = cur[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int step = map.getOrDefault(x * n + y, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(grid[x][y] == 1) return step;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int[] d : dir){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int next_x = x + d[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int next_y = y + d[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(next_x &gt;= 0 &amp;&amp; next_x &lt; n &amp;&amp; next_y &gt;= 0 &amp;&amp; next_y &lt; n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    int key = next_x * n + next_y;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(!map.containsKey(key)) map.put(key, step + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.offer(new int[]{next_x, next_y});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// 将多源BFS转为单源BFS，优化时间复杂度：O(n^2) ,并且这个海洋肯定是被离他最近的陆地给扩散到的！</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int[][] dir = new int[][]{{0,1},{0,-1},{1,0},{-1,0}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int maxDistance(int[][] grid) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int n = grid.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Map&lt;Integer, Integer&gt; map = new HashMap&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;int[]&gt; deque = new ArrayDeque&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int res = -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; n; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(grid[i][j] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.offer(new int[]{i,j});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int[] cur = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int x = cur[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int y = cur[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int step = map.getOrDefault(x * n + y, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int[] d : dir){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int next_x = x + d[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int next_y = y + d[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(next_x &gt;= 0 &amp;&amp; next_x &lt; n &amp;&amp; next_y &gt;= 0 &amp;&amp; next_y &lt; n &amp;&amp; grid[next_x][next_y] == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    int key = next_x * n + next_y;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    grid[next_x][next_y] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(!map.containsKey(key)) map.put(key, step + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.offer(new int[]{next_x, next_y});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    res = Math.max(res, step + 1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="1765-地图中的最高点"><a href="https://leetcode.cn/problems/map-of-highest-peak/" target="_blank" rel="noopener noreferrer">1765. 地图中的最高点</a><a href="#1765-地图中的最高点" class="hash-link" aria-label="Direct link to 1765-地图中的最高点" title="Direct link to 1765-地图中的最高点">​</a></h3>
<p>给你一个大小为 <code>m x n</code> 的整数矩阵 <code>isWater</code> ，它代表了一个由 <strong>陆地</strong> 和 <strong>水域</strong> 单元格组成的地图。</p>
<ul>
<li>如果 <code>isWater[i][j] == 0</code> ，格子 <code>(i, j)</code> 是一个 <strong>陆地</strong> 格子。</li>
<li>如果 <code>isWater[i][j] == 1</code> ，格子 <code>(i, j)</code> 是一个 <strong>水域</strong> 格子。</li>
</ul>
<p>你需要按照如下规则给每个单元格安排 高度：</p>
<ul>
<li>每个格子的高度都必须是非负的。</li>
<li>如果一个格子是 <strong>水域</strong> ，那么它的高度必须为 <code>0</code> 。</li>
<li>任意相邻的格子高度差 <strong>至多</strong> 为 <code>1</code> 。当两个格子在正东、南、西、北方向上相互紧挨着，就称它们为相邻的格子。（也就是说它们有一条公共边）</li>
</ul>
<p>找到一种安排高度的方案，使得矩阵中的最高高度值 <strong>最大</strong> 。</p>
<p>请你返回一个大小为 <code>m x n</code> 的整数矩阵 <code>height</code> ，其中 <code>height[i][j]</code> 是格子 <code>(i, j)</code> 的高度。如果有多种解法，请返回 <strong>任意一个</strong> 。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[][] dir = {{1,0},{-1,0},{0,1},{0,-1}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[][] highestPeak(int[][] isWater) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(isWater == null) return null;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int m = isWater.length, n = isWater[0].length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] res = new int[m][n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;int[]&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; m; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; n; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(isWater[i][j] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.offer(new int[]{i,j});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int[] cur = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int x = cur[0], y = cur[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int[] d : dir){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int next_x = x + d[0], next_y = y + d[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(next_x &gt;= 0 &amp;&amp; next_x &lt; m &amp;&amp; next_y &gt;= 0 &amp;&amp; next_y &lt; n &amp;&amp; isWater[next_x][next_y] == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    isWater[next_x][next_y] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    res[next_x][next_y] = res[x][y] + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    deque.offer(new int[]{next_x, next_y});</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="floyd-算法">Floyd 算法<a href="#floyd-算法" class="hash-link" aria-label="Direct link to Floyd 算法" title="Direct link to Floyd 算法">​</a></h2>
<p><strong>Floyd 算法对边的权值正负没有要求，都可以处理</strong>。</p>
<p>Floyd 算法核心思想是动态规划。</p>
<p>这里分两种情况：</p>
<ol>
<li>
<p>节点 i 到 节点 j 的最短路径经过节点 k</p>
<p><code>grid[i][j][k] = grid[i][k][k - 1] + grid[k][j][k - 1]</code></p>
</li>
<li>
<p>节点 i 到 节点 j 的最短路径不经过节点 k</p>
<p><code>grid[i][j][k] = grid[i][j][k - 1]</code></p>
</li>
</ol>
<p>求最短路，自然就是取两种情况的最小值。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="题目-5">题目<a href="#题目-5" class="hash-link" aria-label="Direct link to 题目" title="Direct link to 题目">​</a></h3>
<p><a href="https://kamacoder.com/problempage.php?pid=1155" target="_blank" rel="noopener noreferrer">卡码网：97. 小明逛公园</a></p>
<p>【题目描述】</p>
<p>小明喜欢去公园散步，公园内布置了许多的景点，相互之间通过小路连接，小明希望在观看景点的同时，能够节省体力，走最短的路径。</p>
<p>给定一个公园景点图，图中有 N 个景点（编号为 1 到 N），以及 M 条双向道路连接着这些景点。每条道路上行走的距离都是已知的。</p>
<p>小明有 Q 个观景计划，每个计划都有一个起点 start 和一个终点 end，表示他想从景点 start 前往景点 end。由于小明希望节省体力，他想知道每个观景计划中从起点到终点的最短路径长度。 请你帮助小明计算出每个观景计划的最短路径长度。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//dijkstra</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] graph = new int[N+1][N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= N; i++) Arrays.fill(graph[i], Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int val = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph[s][t] = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph[t][s] = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int Q = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] start = new int[Q];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] end = new int[Q];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; Q; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            start[i] = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            end[i] = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; Q; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int[] minDist = new int[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            Arrays.fill(minDist, Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            minDist[start[i]] = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            boolean[] visited = new boolean[N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int k  = 1; k &lt;= N; k++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int min_val = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int cur = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                for(int j = 1; j &lt;= N; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(!visited[j] &amp;&amp; minDist[j] &lt; min_val){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        min_val = minDist[j];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        cur = j;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                visited[cur] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                for(int j = 1; j &lt;= N; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(!visited[j] &amp;&amp; graph[cur][j] != Integer.MAX_VALUE &amp;&amp; minDist[j] &gt; minDist[cur] + graph[cur][j]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        minDist[j] = minDist[cur] + graph[cur][j];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(minDist[end[i]] == Integer.MAX_VALUE)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                System.out.println(-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                System.out.println(minDist[end[i]]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// Floyd 算法</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int M = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][][] graph = new int[N+1][N+1][N+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt;= N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt;= N; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                Arrays.fill(graph[i][j], Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; M; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int s = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int t = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int val = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph[s][t][0] = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph[t][s][0] = val;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int Q = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] start = new int[Q];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] end = new int[Q];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; Q; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            start[i] = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            end[i] = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = new int[Q];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int k = 1; k &lt;= N; k++){ // 注意3层循环的顺序</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int i = 1; i &lt;= N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                for(int j = 1; j &lt;= N; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(graph[i][k][k-1] != Integer.MAX_VALUE &amp;&amp; graph[k][j][k-1] != Integer.MAX_VALUE)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        graph[i][j][k] = Math.min(graph[i][j][k-1], graph[i][k][k-1] + graph[k][j][k-1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    else</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        graph[i][j][k] = graph[i][j][k-1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; Q; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(graph[start[i]][end[i]][N] != Integer.MAX_VALUE)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                System.out.println(graph[start[i]][end[i]][N]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                System.out.println(-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="a--算法精讲-a-star-算法">A * 算法精讲 （A star 算法）<a href="#a--算法精讲-a-star-算法" class="hash-link" aria-label="Direct link to A * 算法精讲 （A star 算法）" title="Direct link to A * 算法精讲 （A star 算法）">​</a></h2>
<p><a href="https://kamacoder.com/problempage.php?pid=1203" target="_blank" rel="noopener noreferrer">卡码网：126. 骑士的攻击</a></p>
<p>题目描述</p>
<p>在象棋中，马和象的移动规则分别是“马走日”和“象走田”。现给定骑士的起始坐标和目标坐标，要求根据骑士的移动规则，计算从起点到达目标点所需的最短步数。</p>
<p>骑士移动规则如图，红色是起始位置，黄色是骑士可以走的地方。</p>
<p><img decoding="async" loading="lazy" alt="20240626104833" src="/assets/images/20240626104833-58081b702130f6542402da9d2069c645.png" width="568" height="500" class="img_ev3q"></p>
<p>棋盘大小 1000 x 1000（棋盘的 x 和 y 坐标均在 [1, 1000] 区间内，包含边界）</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// astar PriorityQueue会超时</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Edge{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int a1, a2, b1, b2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Edge(int a1, int a2, int b1, int b2){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.a1 = a1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.a2 = a2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.b1 = b1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.b2 = b2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Knight{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int x, y, g, h; // g: 当前步数, h: 估计剩余步数</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Knight(int x, int y, int g, int h){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.x = x;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.y = y;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.g = g;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.h = h;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class MyComparator implements Comparator&lt;Knight&gt;{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int compare(Knight o1, Knight o2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Integer.compare(o1.g + o1.h, o2.g + o2.h);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int[][] dir = {{-2,-1},{-1,-2},{1,-2},{2,-1},{-2,1},{-1,2},{1,2},{2,1}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Edge&gt; graph = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int a1 = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int a2 = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int b1 = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int b2 = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.add(new Edge(a1, a2, b1, b2));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(Edge e : graph){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            astar(e);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static void astar(Edge e){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        PriorityQueue&lt;Knight&gt; pq = new PriorityQueue&lt;&gt;(new MyComparator());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        pq.offer(new Knight(e.a1, e.a2, 0, heuristic(e.a1, e.a2, e.b1, e.b2)));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] visited = new int[1001][1001];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        visited[e.a1][e.a2] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!pq.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            Knight cur = pq.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int curX = cur.x, curY = cur.y, curH = cur.h, curG = cur.g;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(curX == e.b1 &amp;&amp; curY == e.b2){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                System.out.println(visited[curX][curY]-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int i = 0; i &lt; 8; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int nextX = curX + dir[i][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int nextY = curY + dir[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(nextX &gt;= 1 &amp;&amp; nextX &lt;= 1000 &amp;&amp; nextY &gt;= 1 &amp;&amp; nextY &lt;= 1000 &amp;&amp; visited[nextX][nextY] == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    pq.offer(new Knight(nextX, nextY, curG + 3, heuristic(nextX, nextY, e.b1, e.b2)));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    visited[nextX][nextY] = visited[curX][curY] + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static int heuristic(int x1, int y1, int x2, int y2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return Math.abs(x1 - x2) + Math.abs(y1 - y2); // 曼哈顿距离作为 A* 估计函数</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.*;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Edge{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int a1, a2, b1, b2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Edge(int a1, int a2, int b1, int b2){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.a1 = a1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.a2 = a2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.b1 = b1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.b2 = b2;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Knight{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    int x, y, g, h; // g: 当前步数, h: 估计剩余步数</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    Knight(int x, int y, int g, int h){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.x = x;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.y = y;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.g = g;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        this.h = h;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class MyComparator implements Comparator&lt;Knight&gt;{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    @Override</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int compare(Knight o1, Knight o2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return ((o1.g + o1.h) - (o2.g + o2.h));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">public class Main{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int[][] visited = new int[1001][1001];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static int[][] dir = {{-2,-1},{-1,-2},{1,-2},{2,-1},{-2,1},{-1,2},{1,2},{2,1}};</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public static void main(String[] args){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Scanner scanner = new Scanner(System.in);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int N = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        List&lt;Edge&gt; graph = new ArrayList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 1; i &lt;= N; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int a1 = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int a2 = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int b1 = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int b2 = scanner.nextInt();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            graph.add(new Edge(a1, a2, b1, b2));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(Edge e : graph){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            astar(e);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        scanner.close();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static void astar(Edge e){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        PriorityQueue&lt;Knight&gt; pq = new PriorityQueue&lt;&gt;(new MyComparator());</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        pq.offer(new Knight(e.a1, e.a2, 0, heuristic(e.a1, e.a2, e.b1, e.b2)));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int[] arr : visited) Arrays.fill(arr, 0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        visited[e.a1][e.a2] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!pq.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            Knight cur = pq.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int curX = cur.x, curY = cur.y, curG = cur.g;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(curX == e.b1 &amp;&amp; curY == e.b2){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                System.out.println(visited[curX][curY]-1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int i = 0; i &lt; 8; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int nextX = curX + dir[i][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                int nextY = curY + dir[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(nextX &gt;= 1 &amp;&amp; nextX &lt;= 1000 &amp;&amp; nextY &gt;= 1 &amp;&amp; nextY &lt;= 1000 &amp;&amp; visited[nextX][nextY] == 0){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    pq.offer(new Knight(nextX, nextY, curG + 5, heuristic(nextX, nextY, e.b1, e.b2)));</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    visited[nextX][nextY] = visited[curX][curY] + 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private static int heuristic(int x1, int y1, int x2, int y2) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return (x1 - x2)*(x1 - x2) + (y1 - y2)*(y1 - y2);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="总结">总结<a href="#总结" class="hash-link" aria-label="Direct link to 总结" title="Direct link to 总结">​</a></h2>
<p><img decoding="async" loading="lazy" alt="img" src="/assets/images/20240508121355-e31ffb37aa16c2e7f116bb59e9d20124.png" width="1728" height="574" class="img_ev3q"></p>
<p>（因为 A * 属于启发式搜索，和上面最短路算法并不是一类，不适合一起对比)</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="其他">其他<a href="#其他" class="hash-link" aria-label="Direct link to 其他" title="Direct link to 其他">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="841钥匙和房间">841.钥匙和房间<a href="#841钥匙和房间" class="hash-link" aria-label="Direct link to 841.钥匙和房间" title="Direct link to 841.钥匙和房间">​</a></h3>
<p><a href="https://leetcode.cn/problems/keys-and-rooms/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>有 N 个房间，开始时你位于 0 号房间。每个房间有不同的号码：0，1，2，...，N-1，并且房间里可能有一些钥匙能使你进入下一个房间。</p>
<p>在形式上，对于每个房间 i 都有一个钥匙列表 rooms[i]，每个钥匙 rooms[i][j] 由 [0,1，...，N-1] 中的一个整数表示，其中 N = rooms.length。 钥匙 rooms[i][j] = v 可以打开编号为 v 的房间。</p>
<p>最初，除 0 号房间外的其余所有房间都被锁住。</p>
<p>你可以自由地在房间之间来回走动。</p>
<p>如果能进入每个房间返回 true，否则返回 false。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// BFS solution</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.Deque;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.LinkedList;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.List;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(rooms == null || rooms.size() == 0) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] visited = new boolean[rooms.size()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Deque&lt;Integer&gt; deque = new LinkedList&lt;&gt;();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        deque.offer(0);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        while(!deque.isEmpty()){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur = deque.poll();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(!visited[cur]) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                for(int n : rooms.get(cur)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    if(!visited[n]) deque.offer(n);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                visited[cur] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(boolean v : visited) if(!v) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//DFS(更快)</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.List;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">// DFS solution</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void dfs(List&lt;List&lt;Integer&gt;&gt; rooms, int cur, boolean[] visited){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(visited[cur]) return;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        visited[cur] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i : rooms.get(cur)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            dfs(rooms, i, visited);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean canVisitAllRooms(List&lt;List&lt;Integer&gt;&gt; rooms) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(rooms == null || rooms.size() == 0) return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] visited = new boolean[rooms.size()];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dfs(rooms, 0, visited);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(boolean v : visited) if(!v) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="127-单词接龙">127. 单词接龙<a href="#127-单词接龙" class="hash-link" aria-label="Direct link to 127. 单词接龙" title="Direct link to 127. 单词接龙">​</a></h3>
<p><a href="https://leetcode.cn/problems/word-ladder/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>字典 wordList 中从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p>
<ul>
<li>序列中第一个单词是 beginWord 。</li>
<li>序列中最后一个单词是 endWord 。</li>
<li>每次转换只能改变一个字母。</li>
<li>转换过程中的中间单词必须是字典 wordList 中的单词。</li>
<li>给你两个单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</li>
</ul>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.Arrays;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">import java.util.List;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(!wordList.contains(endWord)) return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int n = wordList.size();</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[][] graph = new int[n+1][n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = i+1; j &lt; n; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(isAdjacent(wordList.get(i), wordList.get(j))){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    graph[i][j] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    graph[j][i] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(isAdjacent(wordList.get(i), beginWord)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                graph[i][n] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                graph[n][i] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        boolean[] visited = new boolean[n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] MinDist = new int[n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        Arrays.fill(MinDist, Integer.MAX_VALUE);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        MinDist[n] = 1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n+1; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int min = Integer.MAX_VALUE;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            int cur = -1;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; n+1; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(MinDist[j] &lt; min &amp;&amp; !visited[j]){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    min = MinDist[j];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    cur = j;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(cur == -1) break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            visited[cur] = true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            for(int j = 0; j &lt; n+1; j++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(graph[cur][j] == 1){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    MinDist[j] = Math.min(min + 1, MinDist[j]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n+1; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(endWord.equals(wordList.get(i))) return MinDist[i] == Integer.MAX_VALUE ? 0 : MinDist[i];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isAdjacent(String word1, String word2){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(word1.length() != word2.length()) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int cnt = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; word1.length(); i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(word1.charAt(i)!= word2.charAt(i)){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                cnt++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                if(cnt &gt; 1) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="684冗余连接">684.冗余连接<a href="#684冗余连接" class="hash-link" aria-label="Direct link to 684.冗余连接" title="Direct link to 684.冗余连接">​</a></h3>
<p><a href="https://leetcode.cn/problems/redundant-connection/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>树可以看成是一个连通且 无环 的 无向 图。</p>
<p>给定往一棵 n 个节点 (节点值 1 ～ n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。</p>
<p>请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">//b</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] father;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int n;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void init_disjoint_set(int n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father = new int[n+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            father[i] = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void union(int x, int y) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int fx = find(x);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int fy = find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (fx != fy) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            father[fx] = fy;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int find(int x) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (father[x] == x) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return x;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father[x] = find(father[x]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return father[x];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private boolean isSame(int x, int y) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return find(x) == find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[] findRedundantConnection(int[][] edges) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        n = edges.length;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        init_disjoint_set(n);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int[] edge : edges){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(isSame(edge[0], edge[1])) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res[0] = edge[0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res[1] = edge[1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            union(edge[0], edge[1]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="685冗余连接-ii">685.冗余连接 II<a href="#685冗余连接-ii" class="hash-link" aria-label="Direct link to 685.冗余连接 II" title="Direct link to 685.冗余连接 II">​</a></h3>
<p><a href="https://leetcode.cn/problems/redundant-connection-ii/" target="_blank" rel="noopener noreferrer">力扣题目链接</a></p>
<p>在本问题中，有根树指满足以下条件的 有向 图。该树只有一个根节点，所有其他节点都是该根节点的后继。该树除了根节点之外的每一个节点都有且只有一个父节点，而根节点没有父节点。</p>
<p>输入一个有向图，该图由一个有着 n 个节点（节点值不重复，从 1 到 n）的树及一条附加的有向边构成。附加的边包含在 1 到 n 中的两个不同顶点间，这条附加的边不属于树中已存在的边。</p>
<p>结果图是一个以边组成的二维数组 edges 。 每个元素是一对 [ui, vi]，用以表示 有向 图中连接顶点 ui 和顶点 vi 的边，其中 ui 是 vi 的一个父节点。</p>
<p>返回一条能删除的边，使得剩下的图是有 n 个节点的有根树。若有多个答案，返回最后出现在给定二维数组的答案。</p>
<p>解答：</p>
<div class="language-java codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-java codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">class Solution {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int[] father;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    private int n;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void initDisJoint(int n){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father = new int[n];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; n; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            father[i] = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public void union(int x, int y) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int fx = find(x);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int fy = find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (fx != fy) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            father[fx] = fy;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int find(int x) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if (father[x] == x) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return x;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        father[x] = find(father[x]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return father[x];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isSame(int x, int y) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return find(x) == find(y);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[] findRedundantDirectedConnection(int[][] edges) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] inDegree = new int[edges.length+1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int temp = 0;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] twoinDegree = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; edges.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            inDegree[edges[i][1]]++;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(inDegree[edges[i][1]] &gt; 1) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                temp = edges[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                twoinDegree[1] = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; edges.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(edges[i][1] == temp){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                twoinDegree[0] = i;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                break;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        if(twoinDegree[1] != 0) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if (isTreeRemoveEdge(edges, twoinDegree[1])) return edges[twoinDegree[1]];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            else return edges[twoinDegree[0]];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        else{</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            return detectCycle(edges);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public boolean isTreeRemoveEdge(int[][] edges, int deletingEdge){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        initDisJoint(edges.length+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; edges.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(i == deletingEdge) continue;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(isSame(edges[i][0], edges[i][1])) return false;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            union(edges[i][1], edges[i][0]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return true;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    public int[] detectCycle(int[][] edges) {</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        initDisJoint(edges.length+1);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        int[] res = new int[2];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        for(int i = 0; i &lt; edges.length; i++){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            if(isSame(edges[i][0], edges[i][1])){</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res[0] = edges[i][0];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                res[1] = edges[i][1];</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            union(edges[i][1], edges[i][0]);</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        return res;</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    }</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="200-岛屿数量"><a href="https://leetcode.cn/problems/number-of-islands/" target="_blank" rel="noopener noreferrer">200. 岛屿数量</a><a href="#200-岛屿数量" class="hash-link" aria-label="Direct link to 200-岛屿数量" title="Direct link to 200-岛屿数量">​</a></h3>
<p>给你一个由 <code>&#x27;1&#x27;</code>（陆地）和 <code>&#x27;0&#x27;</code>（水)组成的的二维网格，请你计算网格中岛屿的数量。</p>
<p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p>
<p>此外，你可以假设该网格的四条边均被水包围。</p>
<p>解答:</p>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token keyword" style="color:hsl(301, 63%, 40%)">class</span><span class="token plain"> </span><span class="token class-name" style="color:hsl(35, 99%, 36%)">Solution</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">def</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">numIslands</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">self</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"> List</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">List</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token builtin" style="color:hsl(119, 34%, 47%)">str</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        m </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">len</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        n </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">len</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        cnt </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        visited </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">*</span><span class="token plain"> n </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> _ </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">range</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">m</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dirs </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">def</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> y</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token boolean" style="color:hsl(35, 99%, 36%)">None</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> x </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">or</span><span class="token plain"> x </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;=</span><span class="token plain"> m </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">or</span><span class="token plain"> y </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">or</span><span class="token plain"> y </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;=</span><span class="token plain"> n </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">or</span><span class="token plain"> visited</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">y</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            visited</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">y</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">y</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> </span><span class="token string" style="color:hsl(119, 34%, 47%)">&quot;1&quot;</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> j </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> dirs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">x</span><span class="token operator" style="color:hsl(221, 87%, 60%)">+</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> y</span><span class="token operator" style="color:hsl(221, 87%, 60%)">+</span><span class="token plain">j</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> x </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">range</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">m</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> y </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">range</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">n</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> visited</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">y</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> y</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    cnt </span><span class="token operator" style="color:hsl(221, 87%, 60%)">+=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">y</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> </span><span class="token string" style="color:hsl(119, 34%, 47%)">&quot;1&quot;</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">else</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> cnt</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="994-腐烂的橘子"><a href="https://leetcode.cn/problems/rotting-oranges/" target="_blank" rel="noopener noreferrer">994. 腐烂的橘子</a><a href="#994-腐烂的橘子" class="hash-link" aria-label="Direct link to 994-腐烂的橘子" title="Direct link to 994-腐烂的橘子">​</a></h3>
<p>在给定的 <code>m x n</code> 网格 <code>grid</code> 中，每个单元格可以有以下三个值之一：</p>
<ul>
<li>值 <code>0</code> 代表空单元格；</li>
<li>值 <code>1</code> 代表新鲜橘子；</li>
<li>值 <code>2</code> 代表腐烂的橘子。</li>
</ul>
<p>每分钟，腐烂的橘子 <strong>周围 4   个方向上相邻</strong> 的新鲜橘子都会腐烂。</p>
<p>返回 <em>直到单元格中没有新鲜橘子为止所必须经过的最小分钟数。如果不可能，返回 <code>-1</code></em> 。</p>
<p>解答:</p>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token keyword" style="color:hsl(301, 63%, 40%)">class</span><span class="token plain"> </span><span class="token class-name" style="color:hsl(35, 99%, 36%)">Solution</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">def</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">orangesRotting</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">self</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"> List</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">List</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        m </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">len</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        n </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">len</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        q </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        dirs </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        fresh </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> row </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">enumerate</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> j</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> x </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">enumerate</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">row</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> x </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    fresh </span><span class="token operator" style="color:hsl(221, 87%, 60%)">+=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">elif</span><span class="token plain"> x </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">2</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    q</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">.</span><span class="token plain">append</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> j</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        cnt </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">while</span><span class="token plain"> q </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">and</span><span class="token plain"> fresh</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            cnt </span><span class="token operator" style="color:hsl(221, 87%, 60%)">+=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            temp </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> q</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            q </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> y </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> temp</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> j </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> dirs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    x_next</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> y_next </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> x</span><span class="token operator" style="color:hsl(221, 87%, 60%)">+</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> y</span><span class="token operator" style="color:hsl(221, 87%, 60%)">+</span><span class="token plain">j</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;=</span><span class="token plain"> x_next </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token plain"> m </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">and</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;=</span><span class="token plain"> y_next </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token plain"> n </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">and</span><span class="token plain"> grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">x_next</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">y_next</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        fresh </span><span class="token operator" style="color:hsl(221, 87%, 60%)">-=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">x_next</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">y_next</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">2</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                        q</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">.</span><span class="token plain">append</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">x_next</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> y_next</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> fresh </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">else</span><span class="token plain"> cnt</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="207-课程表"><a href="https://leetcode.cn/problems/course-schedule/" target="_blank" rel="noopener noreferrer">207. 课程表</a><a href="#207-课程表" class="hash-link" aria-label="Direct link to 207-课程表" title="Direct link to 207-课程表">​</a></h3>
<p>你这个学期必须选修 <code>numCourses</code> 门课程，记为 <code>0</code> 到 <code>numCourses - 1</code> 。</p>
<p>在选修某些课程之前需要一些先修课程。 先修课程按数组 <code>prerequisites</code> 给出，其中 <code>prerequisites[i] = [ai, bi]</code> ，表示如果要学习课程 <code>ai</code> 则 <strong>必须</strong> 先学习课程 <code>bi</code> 。</p>
<ul>
<li>例如，先修课程对 <code>[0, 1]</code> 表示：想要学习课程 <code>0</code> ，你需要先完成课程 <code>1</code> 。</li>
</ul>
<p>请你判断是否可能完成所有课程的学习？如果可以，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p>
<p>解答:</p>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token keyword" style="color:hsl(301, 63%, 40%)">class</span><span class="token plain"> </span><span class="token class-name" style="color:hsl(35, 99%, 36%)">Solution</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">def</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">canFinish</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">self</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> numCourses</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> prerequisites</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"> List</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">List</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">bool</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        g </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> _ </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">range</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">numCourses</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain">y </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> prerequisites</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            g</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">.</span><span class="token plain">append</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">y</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        colors </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">*</span><span class="token plain"> numCourses</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">def</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">bool</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            colors</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> y </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> g</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> colors</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">y</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">or</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">colors</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">y</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">and</span><span class="token plain"> dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">y</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> </span><span class="token boolean" style="color:hsl(35, 99%, 36%)">True</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            colors</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">x</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">2</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> </span><span class="token boolean" style="color:hsl(35, 99%, 36%)">False</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> c </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">enumerate</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">colors</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> c </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">and</span><span class="token plain"> dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> </span><span class="token boolean" style="color:hsl(35, 99%, 36%)">False</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> </span><span class="token boolean" style="color:hsl(35, 99%, 36%)">True</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="64-最小路径和"><a href="https://leetcode.cn/problems/minimum-path-sum/" target="_blank" rel="noopener noreferrer">64. 最小路径和</a><a href="#64-最小路径和" class="hash-link" aria-label="Direct link to 64-最小路径和" title="Direct link to 64-最小路径和">​</a></h3>
<p>给定一个包含非负整数的 <code>m x n</code> 网格 <code>grid</code> ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>**说明：**每次只能向下或者向右移动一步。</p>
<p>解答:</p>
<p><strong>dijkstra 算法</strong></p>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token keyword" style="color:hsl(301, 63%, 40%)">class</span><span class="token plain"> </span><span class="token class-name" style="color:hsl(35, 99%, 36%)">Solution</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">def</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">minPathSum</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">self</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"> List</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">List</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        m </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">len</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        n </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">len</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        visited </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token boolean" style="color:hsl(35, 99%, 36%)">False</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">*</span><span class="token plain"> n </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">for</span><span class="token plain"> _ </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">in</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">range</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">m</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        heap </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        heappush</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">heap</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        min_value </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">while</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">len</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">heap</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            min_value</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> cur </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> heappop</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">heap</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> j </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> cur</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> visited</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">j</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">continue</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> i </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> m</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">and</span><span class="token plain"> j </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> n</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">break</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            visited</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">j</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token boolean" style="color:hsl(35, 99%, 36%)">True</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> j </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token plain"> n</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                heappush</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">heap</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">min_value </span><span class="token operator" style="color:hsl(221, 87%, 60%)">+</span><span class="token plain"> grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">j</span><span class="token operator" style="color:hsl(221, 87%, 60%)">+</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> j</span><span class="token operator" style="color:hsl(221, 87%, 60%)">+</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> i </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token plain"> m</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                heappush</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">heap</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">min_value </span><span class="token operator" style="color:hsl(221, 87%, 60%)">+</span><span class="token plain"> grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">i</span><span class="token operator" style="color:hsl(221, 87%, 60%)">+</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">j</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> </span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">i</span><span class="token operator" style="color:hsl(221, 87%, 60%)">+</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> j</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> min_value</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mspace" style="margin-right:0.1667em"></span><span class="mop">lo<span style="margin-right:0.01389em">g</span></span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mclose">))</span></span></span></span>，其中 <em>m</em> 和 <em>n</em> 分别为 <em>grid</em> 的行数和列数。</li>
<li>空间复杂度：<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em"></span><span class="mord mathnormal" style="margin-right:0.02778em">O</span><span class="mopen">(</span><span class="mord mathnormal">mn</span><span class="mclose">)</span></span></span></span>。</li>
</ul>
<p><strong>DFS(可改写成DP)</strong></p>
<div class="language-python codeBlockContainer_Ckt0 theme-code-block" style="--prism-background-color:hsl(230, 1%, 98%);--prism-color:hsl(230, 8%, 24%)"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-python codeBlock_bY9V thin-scrollbar" style="background-color:hsl(230, 1%, 98%);color:hsl(230, 8%, 24%)"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token keyword" style="color:hsl(301, 63%, 40%)">class</span><span class="token plain"> </span><span class="token class-name" style="color:hsl(35, 99%, 36%)">Solution</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">    </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">def</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">minPathSum</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">self</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"> List</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">List</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        m </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">len</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        n </span><span class="token operator" style="color:hsl(221, 87%, 60%)">=</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">len</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token decorator annotation punctuation" style="color:hsl(119, 34%, 47%)">@cache</span><span class="token plain"> </span><span class="token comment" style="color:hsl(230, 4%, 64%)"># 缓存装饰器，避免重复计算 dfs 的结果（记忆化）</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">def</span><span class="token plain"> </span><span class="token function" style="color:hsl(221, 87%, 60%)">dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> j</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token operator" style="color:hsl(221, 87%, 60%)">&gt;</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">int</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> i </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">or</span><span class="token plain"> j </span><span class="token operator" style="color:hsl(221, 87%, 60%)">&lt;</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> inf</span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">if</span><span class="token plain"> i </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token plain"> </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">and</span><span class="token plain"> j </span><span class="token operator" style="color:hsl(221, 87%, 60%)">==</span><span class="token plain"> </span><span class="token number" style="color:hsl(35, 99%, 36%)">0</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">:</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">                </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">j</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">            </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> </span><span class="token builtin" style="color:hsl(119, 34%, 47%)">min</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">i</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> j</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> j</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><span class="token plain"> </span><span class="token operator" style="color:hsl(221, 87%, 60%)">+</span><span class="token plain"> grid</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">i</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">[</span><span class="token plain">j</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><br></span><span class="token-line" style="color:hsl(230, 8%, 24%)"><span class="token plain">        </span><span class="token keyword" style="color:hsl(301, 63%, 40%)">return</span><span class="token plain"> dfs</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">(</span><span class="token plain">m</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">,</span><span class="token plain"> n</span><span class="token operator" style="color:hsl(221, 87%, 60%)">-</span><span class="token number" style="color:hsl(35, 99%, 36%)">1</span><span class="token punctuation" style="color:hsl(119, 34%, 47%)">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="Copy code to clipboard" title="Copy" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg viewBox="0 0 24 24" class="copyButtonIcon_y97N"><path fill="currentColor" d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg viewBox="0 0 24 24" class="copyButtonSuccessIcon_LjdS"><path fill="currentColor" d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div>
<p><strong>复杂度分析</strong></p>
<ul>
<li>时间复杂度：O(mn)，其中 m 和 n 分别为 grid 的行数和列数。由于每个状态只会计算一次，动态规划的时间复杂度 = 状态个数 × 单个状态的计算时间。本题状态个数等于 O(mn)，单个状态的计算时间为 O(1)，所以总的时间复杂度为 O(mn)。</li>
<li>空间复杂度：O(mn)。保存多少状态，就需要多少空间。</li>
</ul></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="Docs pages"></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#图的基本概念" class="table-of-contents__link toc-highlight">图的基本概念</a><ul><li><a href="#图的种类" class="table-of-contents__link toc-highlight">图的种类</a></li><li><a href="#度" class="table-of-contents__link toc-highlight">度</a></li><li><a href="#连通性" class="table-of-contents__link toc-highlight">连通性</a></li><li><a href="#连通图" class="table-of-contents__link toc-highlight">连通图</a></li><li><a href="#强连通图" class="table-of-contents__link toc-highlight">强连通图</a></li><li><a href="#连通分量" class="table-of-contents__link toc-highlight">连通分量</a></li><li><a href="#强连通分量" class="table-of-contents__link toc-highlight">强连通分量</a></li></ul></li><li><a href="#图的构造" class="table-of-contents__link toc-highlight">图的构造</a><ul><li><a href="#邻接矩阵" class="table-of-contents__link toc-highlight">邻接矩阵</a></li><li><a href="#邻接表" class="table-of-contents__link toc-highlight">邻接表</a></li></ul></li><li><a href="#图的遍历方式" class="table-of-contents__link toc-highlight">图的遍历方式</a></li><li><a href="#dfs-基础知识" class="table-of-contents__link toc-highlight">DFS 基础知识</a></li><li><a href="#代码框架" class="table-of-contents__link toc-highlight">代码框架</a></li><li><a href="#98-所有可达路径" class="table-of-contents__link toc-highlight">98. 所有可达路径</a></li><li><a href="#bsf-基础知识" class="table-of-contents__link toc-highlight">BSF 基础知识</a></li><li><a href="#99-岛屿数量" class="table-of-contents__link toc-highlight">99. 岛屿数量</a></li><li><a href="#01-孤岛 的总面积" class="table-of-contents__link toc-highlight">01. 孤岛的总面积</a></li><li><a href="#102-沉没孤岛" class="table-of-contents__link toc-highlight">102. 沉没孤岛</a></li><li><a href="#103-水流问题" class="table-of-contents__link toc-highlight">103. 水流问题</a></li><li><a href="#104建造最大岛屿" class="table-of-contents__link toc-highlight">104.建造最大岛屿</a></li><li><a href="#110-字符串接龙" class="table-of-contents__link toc-highlight">110. 字符串接龙</a></li><li><a href="#105有向图的完全可达性" class="table-of-contents__link toc-highlight">105.有向图的完全可达性</a></li><li><a href="#106-岛屿的周长" class="table-of-contents__link toc-highlight">106. 岛屿的周长</a></li><li><a href="#并查集理论基础" class="table-of-contents__link toc-highlight">并查集理论基础</a><ul><li><a href="#原理" class="table-of-contents__link toc-highlight">原理</a></li><li><a href="#复杂度分析" class="table-of-contents__link toc-highlight">复杂度分析</a></li><li><a href="#题目" class="table-of-contents__link toc-highlight">题目</a></li></ul></li><li><a href="#最小生成树" class="table-of-contents__link toc-highlight">最小生成树</a><ul><li><a href="#prim-算法" class="table-of-contents__link toc-highlight">prim 算法</a></li><li><a href="#kruskal-算法" class="table-of-contents__link toc-highlight">kruskal 算法</a></li><li><a href="#题目-1" class="table-of-contents__link toc-highlight">题目</a></li></ul></li><li><a href="#拓扑排序精讲" class="table-of-contents__link toc-highlight">拓扑排序精讲</a><ul><li><a href="#题目-2" class="table-of-contents__link toc-highlight">题目</a></li></ul></li><li><a href="#dijkstra" class="table-of-contents__link toc-highlight">dijkstra</a><ul><li><a href="#题目-3" class="table-of-contents__link toc-highlight">题目</a></li></ul></li><li><a href="#bellman_ford-算法" class="table-of-contents__link toc-highlight">Bellman_ford 算法</a><ul><li><a href="#题目-4" class="table-of-contents__link toc-highlight">题目</a></li></ul></li><li><a href="#bellman_ford-之判断负权回路" class="table-of-contents__link toc-highlight">Bellman_ford 之判断负权回路</a></li><li><a href="#bellman_ford-之单源有限最短路" class="table-of-contents__link toc-highlight">bellman_ford 之单源有限最短路</a></li><li><a href="#多源-bfs" class="table-of-contents__link toc-highlight">多源 BFS</a><ul><li><a href="#1162-地图分析" class="table-of-contents__link toc-highlight">1162. 地图分析</a></li><li><a href="#1765-地图中的最高点" class="table-of-contents__link toc-highlight">1765. 地图中的最高点</a></li></ul></li><li><a href="#floyd-算法" class="table-of-contents__link toc-highlight">Floyd 算法</a><ul><li><a href="#题目-5" class="table-of-contents__link toc-highlight">题目</a></li></ul></li><li><a href="#a--算法精讲-a-star-算法" class="table-of-contents__link toc-highlight">A * 算法精讲 （A star 算法）</a></li><li><a href="#总结" class="table-of-contents__link toc-highlight">总结</a></li><li><a href="#其他" class="table-of-contents__link toc-highlight">其他</a><ul><li><a href="#841钥匙和房间" class="table-of-contents__link toc-highlight">841.钥匙和房间</a></li><li><a href="#127-单词接龙" class="table-of-contents__link toc-highlight">127. 单词接龙</a></li><li><a href="#684冗余连接" class="table-of-contents__link toc-highlight">684.冗余连接</a></li><li><a href="#685冗余连接-ii" class="table-of-contents__link toc-highlight">685.冗余连接 II</a></li><li><a href="#200-岛屿数量" class="table-of-contents__link toc-highlight">200. 岛屿数量</a></li><li><a href="#994-腐烂的橘子" class="table-of-contents__link toc-highlight">994. 腐烂的橘子</a></li><li><a href="#207-课程表" class="table-of-contents__link toc-highlight">207. 课程表</a></li><li><a href="#64-最小路径和" class="table-of-contents__link toc-highlight">64. 最小路径和</a></li></ul></li></ul></div></div></div></div></main></div></div></div></div>
</body>
</html>